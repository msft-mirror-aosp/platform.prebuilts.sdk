// Signature format: 2.0
package android {

  public static final class Manifest.permission {
    field public static final String ACCESS_CACHE_FILESYSTEM = "android.permission.ACCESS_CACHE_FILESYSTEM";
    field public static final String ACCESS_DRM_CERTIFICATES = "android.permission.ACCESS_DRM_CERTIFICATES";
    field public static final String ACCESS_FM_RADIO = "android.permission.ACCESS_FM_RADIO";
    field public static final String ACCESS_MTP = "android.permission.ACCESS_MTP";
    field public static final String ACCESS_NETWORK_CONDITIONS = "android.permission.ACCESS_NETWORK_CONDITIONS";
    field public static final String ACCESS_NOTIFICATIONS = "android.permission.ACCESS_NOTIFICATIONS";
    field public static final String ALLOW_ANY_CODEC_FOR_PLAYBACK = "android.permission.ALLOW_ANY_CODEC_FOR_PLAYBACK";
    field public static final String BACKUP = "android.permission.BACKUP";
    field public static final String BIND_CONDITION_PROVIDER_SERVICE = "android.permission.BIND_CONDITION_PROVIDER_SERVICE";
    field public static final String BIND_CONNECTION_SERVICE = "android.permission.BIND_CONNECTION_SERVICE";
    field public static final String BIND_DIRECTORY_SEARCH = "android.permission.BIND_DIRECTORY_SEARCH";
    field public static final String BIND_INCALL_SERVICE = "android.permission.BIND_INCALL_SERVICE";
    field public static final String BIND_KEYGUARD_APPWIDGET = "android.permission.BIND_KEYGUARD_APPWIDGET";
    field public static final String BIND_TRUST_AGENT = "android.permission.BIND_TRUST_AGENT";
    field public static final String BROADCAST_NETWORK_PRIVILEGED = "android.permission.BROADCAST_NETWORK_PRIVILEGED";
    field public static final String CAMERA_DISABLE_TRANSMIT_LED = "android.permission.CAMERA_DISABLE_TRANSMIT_LED";
    field public static final String CAPTURE_AUDIO_HOTWORD = "android.permission.CAPTURE_AUDIO_HOTWORD";
    field public static final String CAPTURE_TV_INPUT = "android.permission.CAPTURE_TV_INPUT";
    field public static final String CONNECTIVITY_INTERNAL = "android.permission.CONNECTIVITY_INTERNAL";
    field public static final String CONTROL_INCALL_EXPERIENCE = "android.permission.CONTROL_INCALL_EXPERIENCE";
    field public static final String CONTROL_VPN = "android.permission.CONTROL_VPN";
    field public static final String CRYPT_KEEPER = "android.permission.CRYPT_KEEPER";
    field public static final String FORCE_STOP_PACKAGES = "android.permission.FORCE_STOP_PACKAGES";
    field public static final String GET_APP_OPS_STATS = "android.permission.GET_APP_OPS_STATS";
    field public static final String HDMI_CEC = "android.permission.HDMI_CEC";
    field public static final String INTERACT_ACROSS_USERS = "android.permission.INTERACT_ACROSS_USERS";
    field public static final String INVOKE_CARRIER_SETUP = "android.permission.INVOKE_CARRIER_SETUP";
    field public static final String LOOP_RADIO = "android.permission.LOOP_RADIO";
    field public static final String MANAGE_ACTIVITY_STACKS = "android.permission.MANAGE_ACTIVITY_STACKS";
    field public static final String MANAGE_CA_CERTIFICATES = "android.permission.MANAGE_CA_CERTIFICATES";
    field public static final String MANAGE_DEVICE_ADMINS = "android.permission.MANAGE_DEVICE_ADMINS";
    field public static final String MANAGE_USB = "android.permission.MANAGE_USB";
    field public static final String MANAGE_USERS = "android.permission.MANAGE_USERS";
    field public static final String MODIFY_APPWIDGET_BIND_PERMISSIONS = "android.permission.MODIFY_APPWIDGET_BIND_PERMISSIONS";
    field public static final String MODIFY_AUDIO_ROUTING = "android.permission.MODIFY_AUDIO_ROUTING";
    field public static final String MODIFY_NETWORK_ACCOUNTING = "android.permission.MODIFY_NETWORK_ACCOUNTING";
    field public static final String MODIFY_PARENTAL_CONTROLS = "android.permission.MODIFY_PARENTAL_CONTROLS";
    field public static final String MOVE_PACKAGE = "android.permission.MOVE_PACKAGE";
    field public static final String PACKAGE_USAGE_STATS = "android.permission.PACKAGE_USAGE_STATS";
    field public static final String PACKAGE_VERIFICATION_AGENT = "android.permission.PACKAGE_VERIFICATION_AGENT";
    field public static final String PERFORM_CDMA_PROVISIONING = "android.permission.PERFORM_CDMA_PROVISIONING";
    field public static final String PROVIDE_TRUST_AGENT = "android.permission.PROVIDE_TRUST_AGENT";
    field public static final String READ_DREAM_STATE = "android.permission.READ_DREAM_STATE";
    field public static final String READ_INSTALL_SESSIONS = "android.permission.READ_INSTALL_SESSIONS";
    field public static final String READ_NETWORK_USAGE_HISTORY = "android.permission.READ_NETWORK_USAGE_HISTORY";
    field public static final String READ_PRIVILEGED_PHONE_STATE = "android.permission.READ_PRIVILEGED_PHONE_STATE";
    field public static final String READ_SEARCH_INDEXABLES = "android.permission.READ_SEARCH_INDEXABLES";
    field public static final String READ_WIFI_CREDENTIAL = "android.permission.READ_WIFI_CREDENTIAL";
    field public static final String REAL_GET_TASKS = "android.permission.REAL_GET_TASKS";
    field public static final String RECEIVE_DATA_ACTIVITY_CHANGE = "android.permission.RECEIVE_DATA_ACTIVITY_CHANGE";
    field public static final String RECEIVE_EMERGENCY_BROADCAST = "android.permission.RECEIVE_EMERGENCY_BROADCAST";
    field public static final String RECOVERY = "android.permission.RECOVERY";
    field public static final String REGISTER_CALL_PROVIDER = "android.permission.REGISTER_CALL_PROVIDER";
    field public static final String REGISTER_CONNECTION_MANAGER = "android.permission.REGISTER_CONNECTION_MANAGER";
    field public static final String REGISTER_SIM_SUBSCRIPTION = "android.permission.REGISTER_SIM_SUBSCRIPTION";
    field public static final String REMOVE_DRM_CERTIFICATES = "android.permission.REMOVE_DRM_CERTIFICATES";
    field public static final String RETRIEVE_WINDOW_CONTENT = "android.permission.RETRIEVE_WINDOW_CONTENT";
    field public static final String SCORE_NETWORKS = "android.permission.SCORE_NETWORKS";
    field public static final String SERIAL_PORT = "android.permission.SERIAL_PORT";
    field public static final String SET_SCREEN_COMPATIBILITY = "android.permission.SET_SCREEN_COMPATIBILITY";
    field public static final String SET_WALLPAPER_COMPONENT = "android.permission.SET_WALLPAPER_COMPONENT";
    field public static final String SHUTDOWN = "android.permission.SHUTDOWN";
    field public static final String STOP_APP_SWITCHES = "android.permission.STOP_APP_SWITCHES";
    field public static final String TV_INPUT_HARDWARE = "android.permission.TV_INPUT_HARDWARE";
    field public static final String UPDATE_APP_OPS_STATS = "android.permission.UPDATE_APP_OPS_STATS";
    field public static final String UPDATE_LOCK = "android.permission.UPDATE_LOCK";
    field public static final String USER_ACTIVITY = "android.permission.USER_ACTIVITY";
    field public static final String WRITE_DREAM_STATE = "android.permission.WRITE_DREAM_STATE";
    field public static final String WRITE_MEDIA_STORAGE = "android.permission.WRITE_MEDIA_STORAGE";
  }

  public static final class R.array {
    field public static final int config_keySystemUuidMapping = 17235973; // 0x1070005
  }

  public static final class R.attr {
    field public static final int searchKeyphrase = 16843871; // 0x101045f
    field public static final int searchKeyphraseId = 16843870; // 0x101045e
    field public static final int searchKeyphraseRecognitionFlags = 16843942; // 0x10104a6
    field public static final int searchKeyphraseSupportedLocales = 16843872; // 0x1010460
  }

  public static final class R.raw {
    field public static final int loaderror = 17825792; // 0x1100000
    field public static final int nodomain = 17825793; // 0x1100001
  }

  public static final class R.style {
    field public static final int Theme_Leanback_FormWizard = 16974544; // 0x10302d0
  }

}

package android.app {

  public class Activity extends android.view.ContextThemeWrapper implements android.content.ComponentCallbacks2 android.view.KeyEvent.Callback android.view.LayoutInflater.Factory2 android.view.View.OnCreateContextMenuListener android.view.Window.Callback {
    method public void convertFromTranslucent();
    method public boolean convertToTranslucent(android.app.Activity.TranslucentConversionListener, android.app.ActivityOptions);
    method public android.app.VoiceInteractor getVoiceInteractor();
    method public boolean isBackgroundVisibleBehind();
    method public boolean isVoiceInteraction();
    method public void onBackgroundVisibleBehindChanged(boolean);
  }

  public static interface Activity.TranslucentConversionListener {
    method public void onTranslucentConversionComplete(boolean);
  }

  public class ActivityManager {
    method public static int getCurrentUser();
  }

  public class AlarmManager {
    method public void set(int, long, long, long, android.app.PendingIntent, android.os.WorkSource);
  }

  public class AppOpsManager {
    field public static final String OPSTR_ACTIVATE_VPN = "android:activate_vpn";
  }

  public class VoiceInteractor {
    method public boolean submitRequest(android.app.VoiceInteractor.Request);
    method public boolean[] supportsCommands(String[]);
  }

  public static class VoiceInteractor.AbortVoiceRequest extends android.app.VoiceInteractor.Request {
    ctor public VoiceInteractor.AbortVoiceRequest(CharSequence, android.os.Bundle);
    method public void onAbortResult(android.os.Bundle);
  }

  public static class VoiceInteractor.CommandRequest extends android.app.VoiceInteractor.Request {
    ctor public VoiceInteractor.CommandRequest(String, android.os.Bundle);
    method public void onCommandResult(android.os.Bundle);
  }

  public static class VoiceInteractor.CompleteVoiceRequest extends android.app.VoiceInteractor.Request {
    ctor public VoiceInteractor.CompleteVoiceRequest(CharSequence, android.os.Bundle);
    method public void onCompleteResult(android.os.Bundle);
  }

  public static class VoiceInteractor.ConfirmationRequest extends android.app.VoiceInteractor.Request {
    ctor public VoiceInteractor.ConfirmationRequest(CharSequence, android.os.Bundle);
    method public void onConfirmationResult(boolean, android.os.Bundle);
  }

  public abstract static class VoiceInteractor.Request {
    ctor public VoiceInteractor.Request();
    method public void cancel();
    method public android.app.Activity getActivity();
    method public android.content.Context getContext();
    method public void onAttached(android.app.Activity);
    method public void onCancel();
    method public void onDetached();
  }

  public class WallpaperManager {
    method public void setDisplayOffset(android.os.IBinder, int, int);
    method public void setDisplayPadding(android.graphics.Rect);
  }

}

package android.app.admin {

  public class DevicePolicyManager {
    method public void clearProfileOwner(android.content.ComponentName);
    method public String getDeviceOwner();
    method public java.util.List<java.lang.String> getPermittedAccessibilityServices(int);
    method public java.util.List<java.lang.String> getPermittedInputMethodsForCurrentUser();
    method public android.content.ComponentName getProfileOwner() throws java.lang.IllegalArgumentException;
    method public String getProfileOwnerNameAsUser(int) throws java.lang.IllegalArgumentException;
    method @Deprecated public boolean setActiveProfileOwner(android.content.ComponentName, String) throws java.lang.IllegalArgumentException;
    field public static final String ACTION_SET_PROFILE_OWNER = "android.app.action.SET_PROFILE_OWNER";
    field public static final String EXTRA_PROFILE_OWNER_NAME = "android.app.extra.PROFILE_OWNER_NAME";
  }

}

package android.app.backup {

  public class BackupDataInput {
    ctor public BackupDataInput(java.io.FileDescriptor);
  }

  public class BackupDataOutput {
    ctor public BackupDataOutput(java.io.FileDescriptor);
  }

  public class BackupManager {
    method public void backupNow();
    method public android.app.backup.RestoreSession beginRestoreSession();
    method public String getCurrentTransport();
    method public boolean isBackupEnabled();
    method public String[] listAllTransports();
    method public String selectBackupTransport(String);
    method public void setAutoRestore(boolean);
    method public void setBackupEnabled(boolean);
  }

  public class BackupTransport {
    ctor public BackupTransport();
    method public int abortFullRestore();
    method public void cancelFullBackup();
    method public int clearBackupData(android.content.pm.PackageInfo);
    method public android.content.Intent configurationIntent();
    method public String currentDestinationString();
    method public android.content.Intent dataManagementIntent();
    method public String dataManagementLabel();
    method public int finishBackup();
    method public void finishRestore();
    method public android.app.backup.RestoreSet[] getAvailableRestoreSets();
    method public android.os.IBinder getBinder();
    method public long getCurrentRestoreSet();
    method public int getNextFullRestoreDataChunk(android.os.ParcelFileDescriptor);
    method public int getRestoreData(android.os.ParcelFileDescriptor);
    method public int initializeDevice();
    method public String name();
    method public android.app.backup.RestoreDescription nextRestorePackage();
    method public int performBackup(android.content.pm.PackageInfo, android.os.ParcelFileDescriptor);
    method public int performFullBackup(android.content.pm.PackageInfo, android.os.ParcelFileDescriptor);
    method public long requestBackupTime();
    method public long requestFullBackupTime();
    method public int sendBackupData(int);
    method public int startRestore(long, android.content.pm.PackageInfo[]);
    method public String transportDirName();
    field public static final int AGENT_ERROR = -1003; // 0xfffffc15
    field public static final int AGENT_UNKNOWN = -1004; // 0xfffffc14
    field public static final int NO_MORE_DATA = -1; // 0xffffffff
    field public static final int TRANSPORT_ERROR = -1000; // 0xfffffc18
    field public static final int TRANSPORT_NOT_INITIALIZED = -1001; // 0xfffffc17
    field public static final int TRANSPORT_OK = 0; // 0x0
    field public static final int TRANSPORT_PACKAGE_REJECTED = -1002; // 0xfffffc16
  }

  public class RestoreDescription implements android.os.Parcelable {
    ctor public RestoreDescription(String, int);
    method public int describeContents();
    method public int getDataType();
    method public String getPackageName();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.app.backup.RestoreDescription> CREATOR;
    field public static final android.app.backup.RestoreDescription NO_MORE_PACKAGES;
    field public static final int TYPE_FULL_STREAM = 2; // 0x2
    field public static final int TYPE_KEY_VALUE = 1; // 0x1
  }

  public abstract class RestoreObserver {
    method public void restoreSetsAvailable(android.app.backup.RestoreSet[]);
  }

  public class RestoreSession {
    method public void endRestoreSession();
    method public int getAvailableRestoreSets(android.app.backup.RestoreObserver);
    method public int restoreAll(long, android.app.backup.RestoreObserver);
    method public int restorePackage(String, android.app.backup.RestoreObserver);
  }

  public class RestoreSet implements android.os.Parcelable {
    ctor public RestoreSet();
    ctor public RestoreSet(String, String, long);
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.app.backup.RestoreSet> CREATOR;
    field public String device;
    field public String name;
    field public long token;
  }

}

package android.bluetooth {

  public final class BluetoothDevice implements android.os.Parcelable {
    method public boolean isConnected();
    method public boolean isEncrypted();
  }

}

package android.bluetooth.le {

  public final class BluetoothLeScanner {
    method public void startTruncatedScan(java.util.List<android.bluetooth.le.TruncatedFilter>, android.bluetooth.le.ScanSettings, android.bluetooth.le.ScanCallback);
  }

  public final class ResultStorageDescriptor implements android.os.Parcelable {
    ctor public ResultStorageDescriptor(int, int, int);
    method public int describeContents();
    method public int getLength();
    method public int getOffset();
    method public int getType();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.bluetooth.le.ResultStorageDescriptor> CREATOR;
  }

  public final class ScanSettings implements android.os.Parcelable {
    field public static final int CALLBACK_TYPE_FIRST_MATCH = 2; // 0x2
    field public static final int CALLBACK_TYPE_MATCH_LOST = 4; // 0x4
    field public static final int SCAN_RESULT_TYPE_ABBREVIATED = 1; // 0x1
    field public static final int SCAN_RESULT_TYPE_FULL = 0; // 0x0
  }

  public static final class ScanSettings.Builder {
    method public android.bluetooth.le.ScanSettings.Builder setCallbackType(int);
    method public android.bluetooth.le.ScanSettings.Builder setScanResultType(int);
  }

  public final class TruncatedFilter {
    ctor public TruncatedFilter(android.bluetooth.le.ScanFilter, java.util.List<android.bluetooth.le.ResultStorageDescriptor>);
    method public android.bluetooth.le.ScanFilter getFilter();
    method public java.util.List<android.bluetooth.le.ResultStorageDescriptor> getStorageDescriptors();
  }

}

package android.content {

  public abstract class Context {
    method public boolean bindServiceAsUser(android.content.Intent, android.content.ServiceConnection, int, android.os.UserHandle);
    field public static final String BACKUP_SERVICE = "backup";
    field public static final String HDMI_CONTROL_SERVICE = "hdmi_control";
    field public static final String NETWORK_SCORE_SERVICE = "network_score";
    field public static final String PERSISTENT_DATA_BLOCK_SERVICE = "persistent_data_block";
    field public static final String WIFI_RTT_SERVICE = "rttmanager";
    field public static final String WIFI_SCANNING_SERVICE = "wifiscanner";
  }

  public class Intent implements java.lang.Cloneable android.os.Parcelable {
    field public static final String CATEGORY_LEANBACK_SETTINGS = "android.intent.category.LEANBACK_SETTINGS";
    field public static final String CATEGORY_VOICE = "android.intent.category.VOICE";
  }

}

package android.content.pm {

  @Deprecated public class ContainerEncryptionParams implements android.os.Parcelable {
    ctor @Deprecated public ContainerEncryptionParams(String, java.security.spec.AlgorithmParameterSpec, javax.crypto.SecretKey) throws java.security.InvalidAlgorithmParameterException;
    ctor @Deprecated public ContainerEncryptionParams(String, java.security.spec.AlgorithmParameterSpec, javax.crypto.SecretKey, String, java.security.spec.AlgorithmParameterSpec, javax.crypto.SecretKey, byte[], long, long, long) throws java.security.InvalidAlgorithmParameterException;
    method @Deprecated public int describeContents();
    method @Deprecated public long getAuthenticatedDataStart();
    method @Deprecated public long getDataEnd();
    method @Deprecated public long getEncryptedDataStart();
    method @Deprecated public String getEncryptionAlgorithm();
    method @Deprecated public javax.crypto.SecretKey getEncryptionKey();
    method @Deprecated public java.security.spec.AlgorithmParameterSpec getEncryptionSpec();
    method @Deprecated public String getMacAlgorithm();
    method @Deprecated public javax.crypto.SecretKey getMacKey();
    method @Deprecated public java.security.spec.AlgorithmParameterSpec getMacSpec();
    method @Deprecated public byte[] getMacTag();
    method @Deprecated public void writeToParcel(android.os.Parcel, int);
    field @Deprecated public static final android.os.Parcelable.Creator<android.content.pm.ContainerEncryptionParams> CREATOR;
    field @Deprecated protected static final String TAG = "ContainerEncryptionParams";
  }

  public class ManifestDigest implements android.os.Parcelable {
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.content.pm.ManifestDigest> CREATOR;
  }

  public abstract class PackageManager {
    field public static final int INSTALL_FAILED_ALREADY_EXISTS = -1; // 0xffffffff
    field public static final int INSTALL_FAILED_CONFLICTING_PROVIDER = -13; // 0xfffffff3
    field public static final int INSTALL_FAILED_CONTAINER_ERROR = -18; // 0xffffffee
    field public static final int INSTALL_FAILED_CPU_ABI_INCOMPATIBLE = -16; // 0xfffffff0
    field public static final int INSTALL_FAILED_DEXOPT = -11; // 0xfffffff5
    field public static final int INSTALL_FAILED_DUPLICATE_PACKAGE = -5; // 0xfffffffb
    field public static final int INSTALL_FAILED_INSUFFICIENT_STORAGE = -4; // 0xfffffffc
    field public static final int INSTALL_FAILED_INTERNAL_ERROR = -110; // 0xffffff92
    field public static final int INSTALL_FAILED_INVALID_APK = -2; // 0xfffffffe
    field public static final int INSTALL_FAILED_INVALID_INSTALL_LOCATION = -19; // 0xffffffed
    field public static final int INSTALL_FAILED_INVALID_URI = -3; // 0xfffffffd
    field public static final int INSTALL_FAILED_MEDIA_UNAVAILABLE = -20; // 0xffffffec
    field public static final int INSTALL_FAILED_MISSING_FEATURE = -17; // 0xffffffef
    field public static final int INSTALL_FAILED_MISSING_SHARED_LIBRARY = -9; // 0xfffffff7
    field public static final int INSTALL_FAILED_NEWER_SDK = -14; // 0xfffffff2
    field public static final int INSTALL_FAILED_NO_SHARED_USER = -6; // 0xfffffffa
    field public static final int INSTALL_FAILED_OLDER_SDK = -12; // 0xfffffff4
    field public static final int INSTALL_FAILED_PACKAGE_CHANGED = -23; // 0xffffffe9
    field public static final int INSTALL_FAILED_REPLACE_COULDNT_DELETE = -10; // 0xfffffff6
    field public static final int INSTALL_FAILED_SHARED_USER_INCOMPATIBLE = -8; // 0xfffffff8
    field public static final int INSTALL_FAILED_TEST_ONLY = -15; // 0xfffffff1
    field public static final int INSTALL_FAILED_UPDATE_INCOMPATIBLE = -7; // 0xfffffff9
    field public static final int INSTALL_FAILED_VERIFICATION_FAILURE = -22; // 0xffffffea
    field public static final int INSTALL_FAILED_VERIFICATION_TIMEOUT = -21; // 0xffffffeb
    field public static final int INSTALL_PARSE_FAILED_BAD_MANIFEST = -101; // 0xffffff9b
    field public static final int INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME = -106; // 0xffffff96
    field public static final int INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID = -107; // 0xffffff95
    field public static final int INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING = -105; // 0xffffff97
    field public static final int INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES = -104; // 0xffffff98
    field public static final int INSTALL_PARSE_FAILED_MANIFEST_EMPTY = -109; // 0xffffff93
    field public static final int INSTALL_PARSE_FAILED_MANIFEST_MALFORMED = -108; // 0xffffff94
    field public static final int INSTALL_PARSE_FAILED_NOT_APK = -100; // 0xffffff9c
    field public static final int INSTALL_PARSE_FAILED_NO_CERTIFICATES = -103; // 0xffffff99
    field public static final int INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION = -102; // 0xffffff9a
    field public static final int INSTALL_SUCCEEDED = 1; // 0x1
  }

}

package android.hardware.hdmi {

  public abstract class HdmiClient {
    method public android.hardware.hdmi.HdmiDeviceInfo getActiveSource();
    method public void sendKeyEvent(int, boolean);
    method public void sendVendorCommand(int, byte[], boolean);
    method public void setVendorCommandListener(android.hardware.hdmi.HdmiControlManager.VendorCommandListener);
  }

  public final class HdmiControlManager {
    method public void addHotplugEventListener(android.hardware.hdmi.HdmiControlManager.HotplugEventListener);
    method public android.hardware.hdmi.HdmiClient getClient(int);
    method public android.hardware.hdmi.HdmiPlaybackClient getPlaybackClient();
    method public android.hardware.hdmi.HdmiTvClient getTvClient();
    method public void removeHotplugEventListener(android.hardware.hdmi.HdmiControlManager.HotplugEventListener);
    field public static final String ACTION_OSD_MESSAGE = "android.hardware.hdmi.action.OSD_MESSAGE";
    field public static final int AVR_VOLUME_MUTED = 101; // 0x65
    field public static final int CLEAR_TIMER_STATUS_CEC_DISABLE = 162; // 0xa2
    field public static final int CLEAR_TIMER_STATUS_CHECK_RECORDER_CONNECTION = 160; // 0xa0
    field public static final int CLEAR_TIMER_STATUS_FAIL_TO_CLEAR_SELECTED_SOURCE = 161; // 0xa1
    field public static final int CLEAR_TIMER_STATUS_TIMER_CLEARED = 128; // 0x80
    field public static final int CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_INFO_AVAILABLE = 2; // 0x2
    field public static final int CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_NO_MATCHING = 1; // 0x1
    field public static final int CLEAR_TIMER_STATUS_TIMER_NOT_CLEARED_RECORDING = 0; // 0x0
    field public static final int CONTROL_STATE_CHANGED_REASON_SETTING = 1; // 0x1
    field public static final int CONTROL_STATE_CHANGED_REASON_STANDBY = 3; // 0x3
    field public static final int CONTROL_STATE_CHANGED_REASON_START = 0; // 0x0
    field public static final int CONTROL_STATE_CHANGED_REASON_WAKEUP = 2; // 0x2
    field public static final int DEVICE_EVENT_ADD_DEVICE = 1; // 0x1
    field public static final int DEVICE_EVENT_REMOVE_DEVICE = 2; // 0x2
    field public static final int DEVICE_EVENT_UPDATE_DEVICE = 3; // 0x3
    field public static final String EXTRA_MESSAGE_EXTRA_PARAM1 = "android.hardware.hdmi.extra.MESSAGE_EXTRA_PARAM1";
    field public static final String EXTRA_MESSAGE_ID = "android.hardware.hdmi.extra.MESSAGE_ID";
    field public static final int ONE_TOUCH_RECORD_ALREADY_RECORDING = 18; // 0x12
    field public static final int ONE_TOUCH_RECORD_CEC_DISABLED = 51; // 0x33
    field public static final int ONE_TOUCH_RECORD_CHECK_RECORDER_CONNECTION = 49; // 0x31
    field public static final int ONE_TOUCH_RECORD_DISALLOW_TO_COPY = 13; // 0xd
    field public static final int ONE_TOUCH_RECORD_DISALLOW_TO_FUTHER_COPIES = 14; // 0xe
    field public static final int ONE_TOUCH_RECORD_FAIL_TO_RECORD_DISPLAYED_SCREEN = 50; // 0x32
    field public static final int ONE_TOUCH_RECORD_INVALID_EXTERNAL_PHYSICAL_ADDRESS = 10; // 0xa
    field public static final int ONE_TOUCH_RECORD_INVALID_EXTERNAL_PLUG_NUMBER = 9; // 0x9
    field public static final int ONE_TOUCH_RECORD_MEDIA_PROBLEM = 21; // 0x15
    field public static final int ONE_TOUCH_RECORD_MEDIA_PROTECTED = 19; // 0x13
    field public static final int ONE_TOUCH_RECORD_NOT_ENOUGH_SPACE = 22; // 0x16
    field public static final int ONE_TOUCH_RECORD_NO_MEDIA = 16; // 0x10
    field public static final int ONE_TOUCH_RECORD_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS = 12; // 0xc
    field public static final int ONE_TOUCH_RECORD_NO_SOURCE_SIGNAL = 20; // 0x14
    field public static final int ONE_TOUCH_RECORD_OTHER_REASON = 31; // 0x1f
    field public static final int ONE_TOUCH_RECORD_PARENT_LOCK_ON = 23; // 0x17
    field public static final int ONE_TOUCH_RECORD_PLAYING = 17; // 0x11
    field public static final int ONE_TOUCH_RECORD_PREVIOUS_RECORDING_IN_PROGRESS = 48; // 0x30
    field public static final int ONE_TOUCH_RECORD_RECORDING_ALREADY_TERMINATED = 27; // 0x1b
    field public static final int ONE_TOUCH_RECORD_RECORDING_ANALOGUE_SERVICE = 3; // 0x3
    field public static final int ONE_TOUCH_RECORD_RECORDING_CURRENTLY_SELECTED_SOURCE = 1; // 0x1
    field public static final int ONE_TOUCH_RECORD_RECORDING_DIGITAL_SERVICE = 2; // 0x2
    field public static final int ONE_TOUCH_RECORD_RECORDING_EXTERNAL_INPUT = 4; // 0x4
    field public static final int ONE_TOUCH_RECORD_RECORDING_TERMINATED_NORMALLY = 26; // 0x1a
    field public static final int ONE_TOUCH_RECORD_UNABLE_ANALOGUE_SERVICE = 6; // 0x6
    field public static final int ONE_TOUCH_RECORD_UNABLE_DIGITAL_SERVICE = 5; // 0x5
    field public static final int ONE_TOUCH_RECORD_UNABLE_SELECTED_SERVICE = 7; // 0x7
    field public static final int ONE_TOUCH_RECORD_UNSUPPORTED_CA = 11; // 0xb
    field public static final int OSD_MESSAGE_ARC_CONNECTED_INVALID_PORT = 1; // 0x1
    field public static final int OSD_MESSAGE_AVR_VOLUME_CHANGED = 2; // 0x2
    field public static final int POWER_STATUS_ON = 0; // 0x0
    field public static final int POWER_STATUS_STANDBY = 1; // 0x1
    field public static final int POWER_STATUS_TRANSIENT_TO_ON = 2; // 0x2
    field public static final int POWER_STATUS_TRANSIENT_TO_STANDBY = 3; // 0x3
    field public static final int POWER_STATUS_UNKNOWN = -1; // 0xffffffff
    field public static final int RESULT_ALREADY_IN_PROGRESS = 4; // 0x4
    field public static final int RESULT_COMMUNICATION_FAILED = 7; // 0x7
    field public static final int RESULT_EXCEPTION = 5; // 0x5
    field public static final int RESULT_INCORRECT_MODE = 6; // 0x6
    field public static final int RESULT_SOURCE_NOT_AVAILABLE = 2; // 0x2
    field public static final int RESULT_SUCCESS = 0; // 0x0
    field public static final int RESULT_TARGET_NOT_AVAILABLE = 3; // 0x3
    field public static final int RESULT_TIMEOUT = 1; // 0x1
    field public static final int TIMER_RECORDING_RESULT_EXTRA_CEC_DISABLED = 3; // 0x3
    field public static final int TIMER_RECORDING_RESULT_EXTRA_CHECK_RECORDER_CONNECTION = 1; // 0x1
    field public static final int TIMER_RECORDING_RESULT_EXTRA_FAIL_TO_RECORD_SELECTED_SOURCE = 2; // 0x2
    field public static final int TIMER_RECORDING_RESULT_EXTRA_NO_ERROR = 0; // 0x0
    field public static final int TIMER_RECORDING_TYPE_ANALOGUE = 2; // 0x2
    field public static final int TIMER_RECORDING_TYPE_DIGITAL = 1; // 0x1
    field public static final int TIMER_RECORDING_TYPE_EXTERNAL = 3; // 0x3
    field public static final int TIMER_STATUS_MEDIA_INFO_NOT_PRESENT = 2; // 0x2
    field public static final int TIMER_STATUS_MEDIA_INFO_PRESENT_NOT_PROTECTED = 0; // 0x0
    field public static final int TIMER_STATUS_MEDIA_INFO_PRESENT_PROTECTED = 1; // 0x1
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_CA_NOT_SUPPORTED = 6; // 0x6
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_CLOCK_FAILURE = 10; // 0xa
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_DATE_OUT_OF_RANGE = 2; // 0x2
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_DUPLICATED = 14; // 0xe
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PHYSICAL_NUMBER = 5; // 0x5
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_INVALID_EXTERNAL_PLUG_NUMBER = 4; // 0x4
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_INVALID_SEQUENCE = 3; // 0x3
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_NO_CA_ENTITLEMENTS = 7; // 0x7
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_NO_FREE_TIME = 1; // 0x1
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_PARENTAL_LOCK_ON = 9; // 0x9
    field public static final int TIMER_STATUS_NOT_PROGRAMMED_UNSUPPORTED_RESOLUTION = 8; // 0x8
    field public static final int TIMER_STATUS_PROGRAMMED_INFO_ENOUGH_SPACE = 8; // 0x8
    field public static final int TIMER_STATUS_PROGRAMMED_INFO_MIGHT_NOT_ENOUGH_SPACE = 11; // 0xb
    field public static final int TIMER_STATUS_PROGRAMMED_INFO_NOT_ENOUGH_SPACE = 9; // 0x9
    field public static final int TIMER_STATUS_PROGRAMMED_INFO_NO_MEDIA_INFO = 10; // 0xa
  }

  public static interface HdmiControlManager.HotplugEventListener {
    method public void onReceived(android.hardware.hdmi.HdmiHotplugEvent);
  }

  public static interface HdmiControlManager.VendorCommandListener {
    method public void onControlStateChanged(boolean, int);
    method public void onReceived(int, int, byte[], boolean);
  }

  public class HdmiDeviceInfo implements android.os.Parcelable {
    ctor public HdmiDeviceInfo();
    method public int describeContents();
    method public int getAdopterId();
    method public int getDeviceId();
    method public int getDevicePowerStatus();
    method public int getDeviceType();
    method public String getDisplayName();
    method public int getId();
    method public int getLogicalAddress();
    method public int getPhysicalAddress();
    method public int getPortId();
    method public int getVendorId();
    method public static int idForCecDevice(int);
    method public static int idForHardware(int);
    method public static int idForMhlDevice(int);
    method public boolean isCecDevice();
    method public boolean isInactivated();
    method public boolean isMhlDevice();
    method public boolean isSourceType();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final int ADDR_INTERNAL = 0; // 0x0
    field public static final android.os.Parcelable.Creator<android.hardware.hdmi.HdmiDeviceInfo> CREATOR;
    field public static final int DEVICE_AUDIO_SYSTEM = 5; // 0x5
    field public static final int DEVICE_INACTIVE = -1; // 0xffffffff
    field public static final int DEVICE_PLAYBACK = 4; // 0x4
    field public static final int DEVICE_RECORDER = 1; // 0x1
    field public static final int DEVICE_RESERVED = 2; // 0x2
    field public static final int DEVICE_TUNER = 3; // 0x3
    field public static final int DEVICE_TV = 0; // 0x0
    field public static final int ID_INVALID = 65535; // 0xffff
    field public static final android.hardware.hdmi.HdmiDeviceInfo INACTIVE_DEVICE;
    field public static final int PATH_INTERNAL = 0; // 0x0
    field public static final int PATH_INVALID = 65535; // 0xffff
    field public static final int PORT_INVALID = -1; // 0xffffffff
  }

  public final class HdmiHotplugEvent implements android.os.Parcelable {
    method public int describeContents();
    method public int getPort();
    method public boolean isConnected();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.hardware.hdmi.HdmiHotplugEvent> CREATOR;
  }

  public final class HdmiPlaybackClient extends android.hardware.hdmi.HdmiClient {
    method public int getDeviceType();
    method public void oneTouchPlay(android.hardware.hdmi.HdmiPlaybackClient.OneTouchPlayCallback);
    method public void queryDisplayStatus(android.hardware.hdmi.HdmiPlaybackClient.DisplayStatusCallback);
  }

  public static interface HdmiPlaybackClient.DisplayStatusCallback {
    method public void onComplete(int);
  }

  public static interface HdmiPlaybackClient.OneTouchPlayCallback {
    method public void onComplete(int);
  }

  public final class HdmiPortInfo implements android.os.Parcelable {
    ctor public HdmiPortInfo(int, int, int, boolean, boolean, boolean);
    method public int describeContents();
    method public int getAddress();
    method public int getId();
    method public int getType();
    method public boolean isArcSupported();
    method public boolean isCecSupported();
    method public boolean isMhlSupported();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.hardware.hdmi.HdmiPortInfo> CREATOR;
    field public static final int PORT_INPUT = 0; // 0x0
    field public static final int PORT_OUTPUT = 1; // 0x1
  }

  public abstract class HdmiRecordListener {
    ctor public HdmiRecordListener();
    method public void onClearTimerRecordingResult(int, int);
    method public void onOneTouchRecordResult(int, int);
    method public abstract android.hardware.hdmi.HdmiRecordSources.RecordSource onOneTouchRecordSourceRequested(int);
    method public void onTimerRecordingResult(int, android.hardware.hdmi.HdmiRecordListener.TimerStatusData);
  }

  public static class HdmiRecordListener.TimerStatusData {
    method public int getDurationHour();
    method public int getDurationMinute();
    method public int getExtraError();
    method public int getMediaInfo();
    method public int getNotProgammedError();
    method public int getProgrammedInfo();
    method public boolean isOverlapped();
    method public boolean isProgrammed();
  }

  public final class HdmiRecordSources {
    method public static boolean checkRecordSource(byte[]);
    method public static android.hardware.hdmi.HdmiRecordSources.OwnSource ofOwnSource();
  }

  public static final class HdmiRecordSources.AnalogueServiceSource extends android.hardware.hdmi.HdmiRecordSources.RecordSource {
  }

  public static final class HdmiRecordSources.DigitalServiceSource extends android.hardware.hdmi.HdmiRecordSources.RecordSource {
  }

  public static final class HdmiRecordSources.ExternalPhysicalAddress extends android.hardware.hdmi.HdmiRecordSources.RecordSource {
  }

  public static final class HdmiRecordSources.ExternalPlugData extends android.hardware.hdmi.HdmiRecordSources.RecordSource {
  }

  public static final class HdmiRecordSources.OwnSource extends android.hardware.hdmi.HdmiRecordSources.RecordSource {
  }

  public abstract static class HdmiRecordSources.RecordSource {
  }

  public class HdmiTimerRecordSources {
    method public static boolean checkTimerRecordSource(int, byte[]);
    method public static android.hardware.hdmi.HdmiTimerRecordSources.Duration durationOf(int, int);
    method public static android.hardware.hdmi.HdmiTimerRecordSources.TimerRecordSource ofAnalogueSource(android.hardware.hdmi.HdmiTimerRecordSources.TimerInfo, android.hardware.hdmi.HdmiRecordSources.AnalogueServiceSource);
    method public static android.hardware.hdmi.HdmiTimerRecordSources.TimerRecordSource ofDigitalSource(android.hardware.hdmi.HdmiTimerRecordSources.TimerInfo, android.hardware.hdmi.HdmiRecordSources.DigitalServiceSource);
    method public static android.hardware.hdmi.HdmiTimerRecordSources.TimerRecordSource ofExternalPhysicalAddress(android.hardware.hdmi.HdmiTimerRecordSources.TimerInfo, android.hardware.hdmi.HdmiRecordSources.ExternalPhysicalAddress);
    method public static android.hardware.hdmi.HdmiTimerRecordSources.TimerRecordSource ofExternalPlug(android.hardware.hdmi.HdmiTimerRecordSources.TimerInfo, android.hardware.hdmi.HdmiRecordSources.ExternalPlugData);
    method public static android.hardware.hdmi.HdmiTimerRecordSources.Time timeOf(int, int);
    method public static android.hardware.hdmi.HdmiTimerRecordSources.TimerInfo timerInfoOf(int, int, android.hardware.hdmi.HdmiTimerRecordSources.Time, android.hardware.hdmi.HdmiTimerRecordSources.Duration, int);
    field public static final int RECORDING_SEQUENCE_REPEAT_FRIDAY = 32; // 0x20
    field public static final int RECORDING_SEQUENCE_REPEAT_MONDAY = 2; // 0x2
    field public static final int RECORDING_SEQUENCE_REPEAT_ONCE_ONLY = 0; // 0x0
    field public static final int RECORDING_SEQUENCE_REPEAT_SATUREDAY = 64; // 0x40
    field public static final int RECORDING_SEQUENCE_REPEAT_SUNDAY = 1; // 0x1
    field public static final int RECORDING_SEQUENCE_REPEAT_THURSDAY = 16; // 0x10
    field public static final int RECORDING_SEQUENCE_REPEAT_TUESDAY = 4; // 0x4
    field public static final int RECORDING_SEQUENCE_REPEAT_WEDNESDAY = 8; // 0x8
  }

  public static final class HdmiTimerRecordSources.Duration {
  }

  public static final class HdmiTimerRecordSources.Time {
  }

  public static final class HdmiTimerRecordSources.TimerInfo {
  }

  public static final class HdmiTimerRecordSources.TimerRecordSource {
  }

  public final class HdmiTvClient extends android.hardware.hdmi.HdmiClient {
    method public void clearTimerRecording(int, int, android.hardware.hdmi.HdmiTimerRecordSources.TimerRecordSource);
    method public void deviceSelect(int, android.hardware.hdmi.HdmiTvClient.SelectCallback);
    method public java.util.List<android.hardware.hdmi.HdmiDeviceInfo> getDeviceList();
    method public int getDeviceType();
    method public void portSelect(int, android.hardware.hdmi.HdmiTvClient.SelectCallback);
    method public void sendMhlVendorCommand(int, int, int, byte[]);
    method public void setHdmiMhlVendorCommandListener(android.hardware.hdmi.HdmiTvClient.HdmiMhlVendorCommandListener);
    method public void setInputChangeListener(android.hardware.hdmi.HdmiTvClient.InputChangeListener);
    method public void setRecordListener(android.hardware.hdmi.HdmiRecordListener);
    method public void setSystemAudioMute(boolean);
    method public void setSystemAudioVolume(int, int, int);
    method public void startOneTouchRecord(int, android.hardware.hdmi.HdmiRecordSources.RecordSource);
    method public void startTimerRecording(int, int, android.hardware.hdmi.HdmiTimerRecordSources.TimerRecordSource);
    method public void stopOneTouchRecord(int);
    field public static final int VENDOR_DATA_SIZE = 16; // 0x10
  }

  public static interface HdmiTvClient.HdmiMhlVendorCommandListener {
    method public void onReceived(int, int, int, byte[]);
  }

  public static interface HdmiTvClient.InputChangeListener {
    method public void onChanged(android.hardware.hdmi.HdmiDeviceInfo);
  }

  public static interface HdmiTvClient.SelectCallback {
    method public void onComplete(int);
  }

}

package android.hardware.location {

  public final class GeofenceHardware {
    ctor public GeofenceHardware(android.hardware.location.IGeofenceHardware);
    method public boolean addGeofence(int, int, android.hardware.location.GeofenceHardwareRequest, android.hardware.location.GeofenceHardwareCallback);
    method public int[] getMonitoringTypes();
    method public int getStatusOfMonitoringType(int);
    method public boolean pauseGeofence(int, int);
    method public boolean registerForMonitorStateChangeCallback(int, android.hardware.location.GeofenceHardwareMonitorCallback);
    method public boolean removeGeofence(int, int);
    method public boolean resumeGeofence(int, int, int);
    method public boolean unregisterForMonitorStateChangeCallback(int, android.hardware.location.GeofenceHardwareMonitorCallback);
    field public static final int GEOFENCE_ENTERED = 1; // 0x1
    field public static final int GEOFENCE_ERROR_ID_EXISTS = 2; // 0x2
    field public static final int GEOFENCE_ERROR_ID_UNKNOWN = 3; // 0x3
    field public static final int GEOFENCE_ERROR_INSUFFICIENT_MEMORY = 6; // 0x6
    field public static final int GEOFENCE_ERROR_INVALID_TRANSITION = 4; // 0x4
    field public static final int GEOFENCE_ERROR_TOO_MANY_GEOFENCES = 1; // 0x1
    field public static final int GEOFENCE_EXITED = 2; // 0x2
    field public static final int GEOFENCE_FAILURE = 5; // 0x5
    field public static final int GEOFENCE_SUCCESS = 0; // 0x0
    field public static final int GEOFENCE_UNCERTAIN = 4; // 0x4
    field public static final int MONITORING_TYPE_FUSED_HARDWARE = 1; // 0x1
    field public static final int MONITORING_TYPE_GPS_HARDWARE = 0; // 0x0
    field public static final int MONITOR_CURRENTLY_AVAILABLE = 0; // 0x0
    field public static final int MONITOR_CURRENTLY_UNAVAILABLE = 1; // 0x1
    field public static final int MONITOR_UNSUPPORTED = 2; // 0x2
    field public static final int SOURCE_TECHNOLOGY_BLUETOOTH = 16; // 0x10
    field public static final int SOURCE_TECHNOLOGY_CELL = 8; // 0x8
    field public static final int SOURCE_TECHNOLOGY_GNSS = 1; // 0x1
    field public static final int SOURCE_TECHNOLOGY_SENSORS = 4; // 0x4
    field public static final int SOURCE_TECHNOLOGY_WIFI = 2; // 0x2
  }

  public abstract class GeofenceHardwareCallback {
    ctor public GeofenceHardwareCallback();
    method public void onGeofenceAdd(int, int);
    method public void onGeofencePause(int, int);
    method public void onGeofenceRemove(int, int);
    method public void onGeofenceResume(int, int);
    method public void onGeofenceTransition(int, int, android.location.Location, long, int);
  }

  public abstract class GeofenceHardwareMonitorCallback {
    ctor public GeofenceHardwareMonitorCallback();
    method @Deprecated public void onMonitoringSystemChange(int, boolean, android.location.Location);
    method public void onMonitoringSystemChange(android.hardware.location.GeofenceHardwareMonitorEvent);
  }

  public class GeofenceHardwareMonitorEvent implements android.os.Parcelable {
    ctor public GeofenceHardwareMonitorEvent(int, int, int, android.location.Location);
    method public int describeContents();
    method public android.location.Location getLocation();
    method public int getMonitoringStatus();
    method public int getMonitoringType();
    method public int getSourceTechnologies();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.hardware.location.GeofenceHardwareMonitorEvent> CREATOR;
  }

  public final class GeofenceHardwareRequest {
    ctor public GeofenceHardwareRequest();
    method public static android.hardware.location.GeofenceHardwareRequest createCircularGeofence(double, double, double);
    method public int getLastTransition();
    method public double getLatitude();
    method public double getLongitude();
    method public int getMonitorTransitions();
    method public int getNotificationResponsiveness();
    method public double getRadius();
    method public int getSourceTechnologies();
    method public int getUnknownTimer();
    method public void setLastTransition(int);
    method public void setMonitorTransitions(int);
    method public void setNotificationResponsiveness(int);
    method public void setSourceTechnologies(int);
    method public void setUnknownTimer(int);
  }

  public final class GeofenceHardwareRequestParcelable implements android.os.Parcelable {
    ctor public GeofenceHardwareRequestParcelable(int, android.hardware.location.GeofenceHardwareRequest);
    method public int describeContents();
    method public int getId();
    method public int getLastTransition();
    method public double getLatitude();
    method public double getLongitude();
    method public int getMonitorTransitions();
    method public int getNotificationResponsiveness();
    method public double getRadius();
    method public int getUnknownTimer();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.hardware.location.GeofenceHardwareRequestParcelable> CREATOR;
  }

  public interface IGeofenceHardware extends android.os.IInterface {
    method public boolean addCircularFence(int, android.hardware.location.GeofenceHardwareRequestParcelable, android.hardware.location.IGeofenceHardwareCallback) throws android.os.RemoteException;
    method public int[] getMonitoringTypes() throws android.os.RemoteException;
    method public int getStatusOfMonitoringType(int) throws android.os.RemoteException;
    method public boolean pauseGeofence(int, int) throws android.os.RemoteException;
    method public boolean registerForMonitorStateChangeCallback(int, android.hardware.location.IGeofenceHardwareMonitorCallback) throws android.os.RemoteException;
    method public boolean removeGeofence(int, int) throws android.os.RemoteException;
    method public boolean resumeGeofence(int, int, int) throws android.os.RemoteException;
    method public void setFusedGeofenceHardware(android.location.IFusedGeofenceHardware) throws android.os.RemoteException;
    method public void setGpsGeofenceHardware(android.location.IGpsGeofenceHardware) throws android.os.RemoteException;
    method public boolean unregisterForMonitorStateChangeCallback(int, android.hardware.location.IGeofenceHardwareMonitorCallback) throws android.os.RemoteException;
  }

  public interface IGeofenceHardwareCallback extends android.os.IInterface {
    method public void onGeofenceAdd(int, int) throws android.os.RemoteException;
    method public void onGeofencePause(int, int) throws android.os.RemoteException;
    method public void onGeofenceRemove(int, int) throws android.os.RemoteException;
    method public void onGeofenceResume(int, int) throws android.os.RemoteException;
    method public void onGeofenceTransition(int, int, android.location.Location, long, int) throws android.os.RemoteException;
  }

  public interface IGeofenceHardwareMonitorCallback extends android.os.IInterface {
    method public void onMonitoringSystemChange(android.hardware.location.GeofenceHardwareMonitorEvent) throws android.os.RemoteException;
  }

}

package android.location {

  public class GpsClock implements android.os.Parcelable {
    method public int describeContents();
    method public double getBiasInNs();
    method public double getBiasUncertaintyInNs();
    method public double getDriftInNsPerSec();
    method public double getDriftUncertaintyInNsPerSec();
    method public long getFullBiasInNs();
    method public short getLeapSecond();
    method public long getTimeInNs();
    method public double getTimeUncertaintyInNs();
    method public byte getType();
    method public boolean hasBiasInNs();
    method public boolean hasBiasUncertaintyInNs();
    method public boolean hasDriftInNsPerSec();
    method public boolean hasDriftUncertaintyInNsPerSec();
    method public boolean hasFullBiasInNs();
    method public boolean hasLeapSecond();
    method public boolean hasTimeUncertaintyInNs();
    method public void reset();
    method public void resetBiasInNs();
    method public void resetBiasUncertaintyInNs();
    method public void resetDriftInNsPerSec();
    method public void resetDriftUncertaintyInNsPerSec();
    method public void resetFullBiasInNs();
    method public void resetLeapSecond();
    method public void resetTimeUncertaintyInNs();
    method public void set(android.location.GpsClock);
    method public void setBiasInNs(double);
    method public void setBiasUncertaintyInNs(double);
    method public void setDriftInNsPerSec(double);
    method public void setDriftUncertaintyInNsPerSec(double);
    method public void setFullBiasInNs(long);
    method public void setLeapSecond(short);
    method public void setTimeInNs(long);
    method public void setTimeUncertaintyInNs(double);
    method public void setType(byte);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.location.GpsClock> CREATOR;
    field public static final byte TYPE_GPS_TIME = 2; // 0x2
    field public static final byte TYPE_LOCAL_HW_TIME = 1; // 0x1
    field public static final byte TYPE_UNKNOWN = 0; // 0x0
  }

  public class GpsMeasurement implements android.os.Parcelable {
    method public int describeContents();
    method public double getAccumulatedDeltaRangeInMeters();
    method public short getAccumulatedDeltaRangeState();
    method public double getAccumulatedDeltaRangeUncertaintyInMeters();
    method public double getAzimuthInDeg();
    method public double getAzimuthUncertaintyInDeg();
    method public int getBitNumber();
    method public long getCarrierCycles();
    method public float getCarrierFrequencyInHz();
    method public double getCarrierPhase();
    method public double getCarrierPhaseUncertainty();
    method public double getCn0InDbHz();
    method public double getCodePhaseInChips();
    method public double getCodePhaseUncertaintyInChips();
    method public double getDopplerShiftInHz();
    method public double getDopplerShiftUncertaintyInHz();
    method public double getElevationInDeg();
    method public double getElevationUncertaintyInDeg();
    method public byte getLossOfLock();
    method public byte getMultipathIndicator();
    method public byte getPrn();
    method public double getPseudorangeInMeters();
    method public double getPseudorangeRateInMetersPerSec();
    method public double getPseudorangeRateUncertaintyInMetersPerSec();
    method public double getPseudorangeUncertaintyInMeters();
    method public long getReceivedGpsTowInNs();
    method public long getReceivedGpsTowUncertaintyInNs();
    method public double getSnrInDb();
    method public short getState();
    method public short getTimeFromLastBitInMs();
    method public double getTimeOffsetInNs();
    method public boolean hasAzimuthInDeg();
    method public boolean hasAzimuthUncertaintyInDeg();
    method public boolean hasBitNumber();
    method public boolean hasCarrierCycles();
    method public boolean hasCarrierFrequencyInHz();
    method public boolean hasCarrierPhase();
    method public boolean hasCarrierPhaseUncertainty();
    method public boolean hasCodePhaseInChips();
    method public boolean hasCodePhaseUncertaintyInChips();
    method public boolean hasDopplerShiftInHz();
    method public boolean hasDopplerShiftUncertaintyInHz();
    method public boolean hasElevationInDeg();
    method public boolean hasElevationUncertaintyInDeg();
    method public boolean hasPseudorangeInMeters();
    method public boolean hasPseudorangeUncertaintyInMeters();
    method public boolean hasSnrInDb();
    method public boolean hasTimeFromLastBitInMs();
    method public boolean isUsedInFix();
    method public void reset();
    method public void resetAzimuthInDeg();
    method public void resetAzimuthUncertaintyInDeg();
    method public void resetBitNumber();
    method public void resetCarrierCycles();
    method public void resetCarrierFrequencyInHz();
    method public void resetCarrierPhase();
    method public void resetCarrierPhaseUncertainty();
    method public void resetCodePhaseInChips();
    method public void resetCodePhaseUncertaintyInChips();
    method public void resetDopplerShiftInHz();
    method public void resetDopplerShiftUncertaintyInHz();
    method public void resetElevationInDeg();
    method public void resetElevationUncertaintyInDeg();
    method public void resetPseudorangeInMeters();
    method public void resetPseudorangeUncertaintyInMeters();
    method public void resetSnrInDb();
    method public void resetTimeFromLastBitInMs();
    method public void set(android.location.GpsMeasurement);
    method public void setAccumulatedDeltaRangeInMeters(double);
    method public void setAccumulatedDeltaRangeState(short);
    method public void setAccumulatedDeltaRangeUncertaintyInMeters(double);
    method public void setAzimuthInDeg(double);
    method public void setAzimuthUncertaintyInDeg(double);
    method public void setBitNumber(int);
    method public void setCarrierCycles(long);
    method public void setCarrierFrequencyInHz(float);
    method public void setCarrierPhase(double);
    method public void setCarrierPhaseUncertainty(double);
    method public void setCn0InDbHz(double);
    method public void setCodePhaseInChips(double);
    method public void setCodePhaseUncertaintyInChips(double);
    method public void setDopplerShiftInHz(double);
    method public void setDopplerShiftUncertaintyInHz(double);
    method public void setElevationInDeg(double);
    method public void setElevationUncertaintyInDeg(double);
    method public void setLossOfLock(byte);
    method public void setMultipathIndicator(byte);
    method public void setPrn(byte);
    method public void setPseudorangeInMeters(double);
    method public void setPseudorangeRateInMetersPerSec(double);
    method public void setPseudorangeRateUncertaintyInMetersPerSec(double);
    method public void setPseudorangeUncertaintyInMeters(double);
    method public void setReceivedGpsTowInNs(long);
    method public void setReceivedGpsTowUncertaintyInNs(long);
    method public void setSnrInDb(double);
    method public void setState(short);
    method public void setTimeFromLastBitInMs(short);
    method public void setTimeOffsetInNs(double);
    method public void setUsedInFix(boolean);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final short ADR_STATE_CYCLE_SLIP = 4; // 0x4
    field public static final short ADR_STATE_RESET = 2; // 0x2
    field public static final short ADR_STATE_UNKNOWN = 0; // 0x0
    field public static final short ADR_STATE_VALID = 1; // 0x1
    field public static final android.os.Parcelable.Creator<android.location.GpsMeasurement> CREATOR;
    field public static final byte LOSS_OF_LOCK_CYCLE_SLIP = 2; // 0x2
    field public static final byte LOSS_OF_LOCK_OK = 1; // 0x1
    field public static final byte LOSS_OF_LOCK_UNKNOWN = 0; // 0x0
    field public static final byte MULTIPATH_INDICATOR_DETECTED = 1; // 0x1
    field public static final byte MULTIPATH_INDICATOR_NOT_USED = 2; // 0x2
    field public static final byte MULTIPATH_INDICATOR_UNKNOWN = 0; // 0x0
    field public static final short STATE_BIT_SYNC = 2; // 0x2
    field public static final short STATE_CODE_LOCK = 1; // 0x1
    field public static final short STATE_SUBFRAME_SYNC = 4; // 0x4
    field public static final short STATE_TOW_DECODED = 8; // 0x8
    field public static final short STATE_UNKNOWN = 0; // 0x0
  }

  public class GpsMeasurementsEvent implements android.os.Parcelable {
    ctor public GpsMeasurementsEvent(android.location.GpsClock, android.location.GpsMeasurement[]);
    method public int describeContents();
    method public android.location.GpsClock getClock();
    method public java.util.Collection<android.location.GpsMeasurement> getMeasurements();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.location.GpsMeasurementsEvent> CREATOR;
    field public static final int STATUS_GPS_LOCATION_DISABLED = 2; // 0x2
    field public static final int STATUS_NOT_SUPPORTED = 0; // 0x0
    field public static final int STATUS_READY = 1; // 0x1
  }

  public static interface GpsMeasurementsEvent.Listener {
    method public void onGpsMeasurementsReceived(android.location.GpsMeasurementsEvent);
    method public void onStatusChanged(int);
  }

  public class GpsNavigationMessage implements android.os.Parcelable {
    method public int describeContents();
    method public byte[] getData();
    method public short getMessageId();
    method public byte getPrn();
    method public short getSubmessageId();
    method public byte getType();
    method public void reset();
    method public void set(android.location.GpsNavigationMessage);
    method public void setData(byte[]);
    method public void setMessageId(short);
    method public void setPrn(byte);
    method public void setSubmessageId(short);
    method public void setType(byte);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.location.GpsNavigationMessage> CREATOR;
    field public static final byte TYPE_CNAV2 = 4; // 0x4
    field public static final byte TYPE_L1CA = 1; // 0x1
    field public static final byte TYPE_L2CNAV = 2; // 0x2
    field public static final byte TYPE_L5CNAV = 3; // 0x3
    field public static final byte TYPE_UNKNOWN = 0; // 0x0
  }

  public class GpsNavigationMessageEvent implements android.os.Parcelable {
    ctor public GpsNavigationMessageEvent(android.location.GpsNavigationMessage);
    method public int describeContents();
    method public android.location.GpsNavigationMessage getNavigationMessage();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.location.GpsNavigationMessageEvent> CREATOR;
    field public static int STATUS_GPS_LOCATION_DISABLED;
    field public static int STATUS_NOT_SUPPORTED;
    field public static int STATUS_READY;
  }

  public static interface GpsNavigationMessageEvent.Listener {
    method public void onGpsNavigationMessageReceived(android.location.GpsNavigationMessageEvent);
    method public void onStatusChanged(int);
  }

  public interface IFusedGeofenceHardware extends android.os.IInterface {
    method public void addGeofences(android.hardware.location.GeofenceHardwareRequestParcelable[]) throws android.os.RemoteException;
    method public boolean isSupported() throws android.os.RemoteException;
    method public void modifyGeofenceOptions(int, int, int, int, int, int) throws android.os.RemoteException;
    method public void pauseMonitoringGeofence(int) throws android.os.RemoteException;
    method public void removeGeofences(int[]) throws android.os.RemoteException;
    method public void resumeMonitoringGeofence(int, int) throws android.os.RemoteException;
  }

  public interface IGpsGeofenceHardware extends android.os.IInterface {
    method public boolean addCircularHardwareGeofence(int, double, double, double, int, int, int, int) throws android.os.RemoteException;
    method public boolean isHardwareGeofenceSupported() throws android.os.RemoteException;
    method public boolean pauseHardwareGeofence(int) throws android.os.RemoteException;
    method public boolean removeHardwareGeofence(int) throws android.os.RemoteException;
    method public boolean resumeHardwareGeofence(int, int) throws android.os.RemoteException;
  }

  public class Location implements android.os.Parcelable {
    method public boolean isComplete();
    method public void makeComplete();
    method public void setIsFromMockProvider(boolean);
  }

  public class LocationManager {
    method public boolean addGpsMeasurementListener(android.location.GpsMeasurementsEvent.Listener);
    method public boolean addGpsNavigationMessageListener(android.location.GpsNavigationMessageEvent.Listener);
    method public void removeGpsMeasurementListener(android.location.GpsMeasurementsEvent.Listener);
    method public void removeGpsNavigationMessageListener(android.location.GpsNavigationMessageEvent.Listener);
    method public void requestLocationUpdates(android.location.LocationRequest, android.location.LocationListener, android.os.Looper);
    method public void requestLocationUpdates(android.location.LocationRequest, android.app.PendingIntent);
  }

  public final class LocationRequest implements android.os.Parcelable {
    method public static android.location.LocationRequest create();
    method public static android.location.LocationRequest createFromDeprecatedCriteria(android.location.Criteria, long, float, boolean);
    method public static android.location.LocationRequest createFromDeprecatedProvider(String, long, float, boolean);
    method public int describeContents();
    method public long getExpireAt();
    method public long getFastestInterval();
    method public boolean getHideFromAppOps();
    method public long getInterval();
    method public int getNumUpdates();
    method public String getProvider();
    method public int getQuality();
    method public float getSmallestDisplacement();
    method public android.os.WorkSource getWorkSource();
    method public android.location.LocationRequest setExpireAt(long);
    method public android.location.LocationRequest setExpireIn(long);
    method public android.location.LocationRequest setFastestInterval(long);
    method public void setHideFromAppOps(boolean);
    method public android.location.LocationRequest setInterval(long);
    method public android.location.LocationRequest setNumUpdates(int);
    method public android.location.LocationRequest setProvider(String);
    method public android.location.LocationRequest setQuality(int);
    method public android.location.LocationRequest setSmallestDisplacement(float);
    method public void setWorkSource(android.os.WorkSource);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final int ACCURACY_BLOCK = 102; // 0x66
    field public static final int ACCURACY_CITY = 104; // 0x68
    field public static final int ACCURACY_FINE = 100; // 0x64
    field public static final android.os.Parcelable.Creator<android.location.LocationRequest> CREATOR;
    field public static final int POWER_HIGH = 203; // 0xcb
    field public static final int POWER_LOW = 201; // 0xc9
    field public static final int POWER_NONE = 200; // 0xc8
  }

}

package android.media {

  public final class AudioAttributes implements android.os.Parcelable {
    method public int getCapturePreset();
    field public static final int FLAG_BEACON = 8; // 0x8
    field public static final int FLAG_HW_HOTWORD = 32; // 0x20
  }

  public static class AudioAttributes.Builder {
    method public android.media.AudioAttributes.Builder setCapturePreset(int);
  }

  public final class AudioFocusInfo implements android.os.Parcelable {
    method public int describeContents();
    method public android.media.AudioAttributes getAttributes();
    method public String getClientId();
    method public int getFlags();
    method public int getGainRequest();
    method public int getLossReceived();
    method public String getPackageName();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.media.AudioFocusInfo> CREATOR;
  }

  public class AudioManager {
    method public int abandonAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener, android.media.AudioAttributes);
    method public boolean isHdmiSystemAudioSupported();
    method public int registerAudioPolicy(android.media.audiopolicy.AudioPolicy);
    method public int requestAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener, android.media.AudioAttributes, int, int) throws java.lang.IllegalArgumentException;
    method public int requestAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener, android.media.AudioAttributes, int, int, android.media.audiopolicy.AudioPolicy) throws java.lang.IllegalArgumentException;
    method public void unregisterAudioPolicyAsync(android.media.audiopolicy.AudioPolicy);
    field public static final int AUDIOFOCUS_FLAG_DELAY_OK = 1; // 0x1
    field public static final int AUDIOFOCUS_FLAG_LOCK = 4; // 0x4
    field public static final int AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS = 2; // 0x2
  }

  public final class MediaDrm {
    method public void unprovisionDevice();
  }

}

package android.media.audiopolicy {

  public class AudioMix {
    field public static final int ROUTE_FLAG_LOOP_BACK = 2; // 0x2
    field public static final int ROUTE_FLAG_RENDER = 1; // 0x1
  }

  public static class AudioMix.Builder {
    ctor public AudioMix.Builder(android.media.audiopolicy.AudioMixingRule) throws java.lang.IllegalArgumentException;
    method public android.media.audiopolicy.AudioMix build() throws java.lang.IllegalArgumentException;
    method public android.media.audiopolicy.AudioMix.Builder setFormat(android.media.AudioFormat) throws java.lang.IllegalArgumentException;
    method public android.media.audiopolicy.AudioMix.Builder setRouteFlags(int) throws java.lang.IllegalArgumentException;
  }

  public class AudioMixingRule {
    field public static final int RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET = 2; // 0x2
    field public static final int RULE_MATCH_ATTRIBUTE_USAGE = 1; // 0x1
  }

  public static class AudioMixingRule.Builder {
    ctor public AudioMixingRule.Builder();
    method public android.media.audiopolicy.AudioMixingRule.Builder addRule(android.media.AudioAttributes, int) throws java.lang.IllegalArgumentException;
    method public android.media.audiopolicy.AudioMixingRule build();
    method public android.media.audiopolicy.AudioMixingRule.Builder excludeRule(android.media.AudioAttributes, int) throws java.lang.IllegalArgumentException;
  }

  public class AudioPolicy {
    method public android.media.AudioRecord createAudioRecordSink(android.media.audiopolicy.AudioMix) throws java.lang.IllegalArgumentException;
    method public android.media.AudioTrack createAudioTrackSource(android.media.audiopolicy.AudioMix) throws java.lang.IllegalArgumentException;
    method public int getFocusDuckingBehavior();
    method public int getStatus();
    method public int setFocusDuckingBehavior(int) throws java.lang.IllegalArgumentException, java.lang.IllegalStateException;
    method public void setRegistration(String);
    method public String toLogFriendlyString();
    field public static final int FOCUS_POLICY_DUCKING_DEFAULT = 0; // 0x0
    field public static final int FOCUS_POLICY_DUCKING_IN_APP = 0; // 0x0
    field public static final int FOCUS_POLICY_DUCKING_IN_POLICY = 1; // 0x1
    field public static final int POLICY_STATUS_REGISTERED = 2; // 0x2
    field public static final int POLICY_STATUS_UNREGISTERED = 1; // 0x1
  }

  public abstract static class AudioPolicy.AudioPolicyFocusListener {
    ctor public AudioPolicy.AudioPolicyFocusListener();
    method public void onAudioFocusGrant(android.media.AudioFocusInfo, int);
    method public void onAudioFocusLoss(android.media.AudioFocusInfo, boolean);
  }

  public abstract static class AudioPolicy.AudioPolicyStatusListener {
    ctor public AudioPolicy.AudioPolicyStatusListener();
    method public void onMixStateUpdate(android.media.audiopolicy.AudioMix);
    method public void onStatusChange();
  }

  public static class AudioPolicy.Builder {
    ctor public AudioPolicy.Builder(android.content.Context);
    method public android.media.audiopolicy.AudioPolicy.Builder addMix(android.media.audiopolicy.AudioMix) throws java.lang.IllegalArgumentException;
    method public android.media.audiopolicy.AudioPolicy build();
    method public void setAudioPolicyFocusListener(android.media.audiopolicy.AudioPolicy.AudioPolicyFocusListener);
    method public void setAudioPolicyStatusListener(android.media.audiopolicy.AudioPolicy.AudioPolicyStatusListener);
    method public android.media.audiopolicy.AudioPolicy.Builder setLooper(android.os.Looper) throws java.lang.IllegalArgumentException;
  }

}

package android.media.tv {

  public final class TvContentRating {
    method public boolean contains(android.media.tv.TvContentRating);
  }

  public final class TvContentRatingSystemInfo implements android.os.Parcelable {
    method public static android.media.tv.TvContentRatingSystemInfo createTvContentRatingSystemInfo(int, android.content.pm.ApplicationInfo);
    method public int describeContents();
    method public android.net.Uri getXmlUri();
    method public boolean isSystemDefined();
    method public void writeToParcel(android.os.Parcel, int);
  }

  public final class TvContract {
    method public static android.net.Uri buildChannelsUriForInput(String, boolean);
    method public static android.net.Uri buildChannelsUriForInput(String, String, boolean);
    method public static boolean isChannelUriForPassthroughInput(android.net.Uri);
  }

  public static final class TvContract.Channels implements android.media.tv.TvContract.BaseTvColumns {
    field public static final String COLUMN_BROWSABLE = "browsable";
    field public static final String COLUMN_LOCKED = "locked";
  }

  public static final class TvContract.Programs.Genres {
    method public static boolean isCanonical(String);
  }

  public static final class TvContract.WatchedPrograms implements android.media.tv.TvContract.BaseTvColumns {
    field public static final String COLUMN_CHANNEL_ID = "channel_id";
    field public static final String COLUMN_DESCRIPTION = "description";
    field public static final String COLUMN_END_TIME_UTC_MILLIS = "end_time_utc_millis";
    field public static final String COLUMN_INTERNAL_SESSION_TOKEN = "session_token";
    field public static final String COLUMN_INTERNAL_TUNE_PARAMS = "tune_params";
    field public static final String COLUMN_START_TIME_UTC_MILLIS = "start_time_utc_millis";
    field public static final String COLUMN_TITLE = "title";
    field public static final String COLUMN_WATCH_END_TIME_UTC_MILLIS = "watch_end_time_utc_millis";
    field public static final String COLUMN_WATCH_START_TIME_UTC_MILLIS = "watch_start_time_utc_millis";
    field public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/watched_program";
    field public static final String CONTENT_TYPE = "vnd.android.cursor.dir/watched_program";
    field public static final android.net.Uri CONTENT_URI;
  }

  public final class TvInputHardwareInfo implements android.os.Parcelable {
    method public int describeContents();
    method public String getAudioAddress();
    method public int getAudioType();
    method public int getDeviceId();
    method public int getHdmiPortId();
    method public int getType();
    method public void readFromParcel(android.os.Parcel);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.media.tv.TvInputHardwareInfo> CREATOR;
    field public static final int TV_INPUT_TYPE_COMPONENT = 6; // 0x6
    field public static final int TV_INPUT_TYPE_COMPOSITE = 3; // 0x3
    field public static final int TV_INPUT_TYPE_DISPLAY_PORT = 10; // 0xa
    field public static final int TV_INPUT_TYPE_DVI = 8; // 0x8
    field public static final int TV_INPUT_TYPE_HDMI = 9; // 0x9
    field public static final int TV_INPUT_TYPE_OTHER_HARDWARE = 1; // 0x1
    field public static final int TV_INPUT_TYPE_SCART = 5; // 0x5
    field public static final int TV_INPUT_TYPE_SVIDEO = 4; // 0x4
    field public static final int TV_INPUT_TYPE_TUNER = 2; // 0x2
    field public static final int TV_INPUT_TYPE_VGA = 7; // 0x7
  }

  public static final class TvInputHardwareInfo.Builder {
    ctor public TvInputHardwareInfo.Builder();
    method public android.media.tv.TvInputHardwareInfo.Builder audioAddress(String);
    method public android.media.tv.TvInputHardwareInfo.Builder audioType(int);
    method public android.media.tv.TvInputHardwareInfo build();
    method public android.media.tv.TvInputHardwareInfo.Builder deviceId(int);
    method public android.media.tv.TvInputHardwareInfo.Builder hdmiPortId(int);
    method public android.media.tv.TvInputHardwareInfo.Builder type(int);
  }

  public final class TvInputInfo implements android.os.Parcelable {
    method public static android.media.tv.TvInputInfo createTvInputInfo(android.content.Context, android.content.pm.ResolveInfo, android.hardware.hdmi.HdmiDeviceInfo, String, String, android.net.Uri) throws java.io.IOException, org.xmlpull.v1.XmlPullParserException;
    method public static android.media.tv.TvInputInfo createTvInputInfo(android.content.Context, android.content.pm.ResolveInfo, android.media.tv.TvInputHardwareInfo, String, android.net.Uri) throws java.io.IOException, org.xmlpull.v1.XmlPullParserException;
    method public android.hardware.hdmi.HdmiDeviceInfo getHdmiDeviceInfo();
    method public boolean isConnectedToHdmiSwitch();
    method public boolean isHidden(android.content.Context);
    method public CharSequence loadCustomLabel(android.content.Context);
  }

  public static final class TvInputInfo.TvInputSettings {
    method public static java.util.Map<java.lang.String,java.lang.String> getCustomLabels(android.content.Context, int);
    method public static java.util.Set<java.lang.String> getHiddenTvInputIds(android.content.Context, int);
    method public static void putCustomLabels(android.content.Context, java.util.Map<java.lang.String,java.lang.String>, int);
    method public static void putHiddenTvInputs(android.content.Context, java.util.Set<java.lang.String>, int);
  }

  public final class TvInputManager {
    method public android.media.tv.TvInputManager.Hardware acquireTvInputHardware(int, android.media.tv.TvInputManager.HardwareCallback, android.media.tv.TvInputInfo);
    method public void addBlockedRating(android.media.tv.TvContentRating);
    method public boolean captureFrame(String, android.view.Surface, android.media.tv.TvStreamConfig);
    method public void createSession(String, android.media.tv.TvInputManager.SessionCallback, android.os.Handler);
    method public java.util.List<android.media.tv.TvStreamConfig> getAvailableTvStreamConfigList(String);
    method public java.util.List<android.media.tv.TvContentRating> getBlockedRatings();
    method public java.util.List<android.media.tv.TvInputHardwareInfo> getHardwareList();
    method public java.util.List<android.media.tv.TvContentRatingSystemInfo> getTvContentRatingSystemList();
    method public boolean isSingleSessionActive();
    method public void releaseTvInputHardware(int, android.media.tv.TvInputManager.Hardware);
    method public void removeBlockedRating(android.media.tv.TvContentRating);
    method public void setParentalControlsEnabled(boolean);
  }

  public static final class TvInputManager.Hardware {
    method public boolean dispatchKeyEventToHdmi(android.view.KeyEvent);
    method public void overrideAudioSink(int, String, int, int, int);
    method public void setStreamVolume(float);
    method public boolean setSurface(android.view.Surface, android.media.tv.TvStreamConfig);
  }

  public abstract static class TvInputManager.HardwareCallback {
    ctor public TvInputManager.HardwareCallback();
    method public abstract void onReleased();
    method public abstract void onStreamConfigChanged(android.media.tv.TvStreamConfig[]);
  }

  public static final class TvInputManager.Session {
    method public void dispatchSurfaceChanged(int, int, int);
    method public String getSelectedTrack(int);
    method public java.util.List<android.media.tv.TvTrackInfo> getTracks(int);
    method public void release();
    method public void selectTrack(int, String);
    method public void sendAppPrivateCommand(String, android.os.Bundle);
    method public void setCaptionEnabled(boolean);
    method public void setStreamVolume(float);
    method public void setSurface(android.view.Surface);
    method public void tune(android.net.Uri);
    method public void tune(android.net.Uri, android.os.Bundle);
  }

  public abstract static class TvInputManager.SessionCallback {
    ctor public TvInputManager.SessionCallback();
    method public void onChannelRetuned(android.media.tv.TvInputManager.Session, android.net.Uri);
    method public void onContentAllowed(android.media.tv.TvInputManager.Session);
    method public void onContentBlocked(android.media.tv.TvInputManager.Session, android.media.tv.TvContentRating);
    method public void onLayoutSurface(android.media.tv.TvInputManager.Session, int, int, int, int);
    method public void onSessionCreated(android.media.tv.TvInputManager.Session);
    method public void onSessionEvent(android.media.tv.TvInputManager.Session, String, android.os.Bundle);
    method public void onSessionReleased(android.media.tv.TvInputManager.Session);
    method public void onTrackSelected(android.media.tv.TvInputManager.Session, int, String);
    method public void onTracksChanged(android.media.tv.TvInputManager.Session, java.util.List<android.media.tv.TvTrackInfo>);
    method public void onVideoAvailable(android.media.tv.TvInputManager.Session);
    method public void onVideoSizeChanged(android.media.tv.TvInputManager.Session, int, int);
    method public void onVideoUnavailable(android.media.tv.TvInputManager.Session, int);
  }

  public abstract static class TvInputManager.TvInputCallback {
    method public void onInputUpdated(String);
  }

  public abstract class TvInputService extends android.app.Service {
    method public android.media.tv.TvInputInfo onHardwareAdded(android.media.tv.TvInputHardwareInfo);
    method public String onHardwareRemoved(android.media.tv.TvInputHardwareInfo);
    method public android.media.tv.TvInputInfo onHdmiDeviceAdded(android.hardware.hdmi.HdmiDeviceInfo);
    method public String onHdmiDeviceRemoved(android.hardware.hdmi.HdmiDeviceInfo);
  }

  public abstract static class TvInputService.Session implements android.view.KeyEvent.Callback {
    method public void layoutSurface(int, int, int, int);
    method public void notifySessionEvent(String, android.os.Bundle);
    method public void onAppPrivateCommand(String, android.os.Bundle);
    method public void onOverlayViewSizeChanged(int, int);
    method public void onSetMain(boolean);
    method public boolean onTune(android.net.Uri, android.os.Bundle);
  }

  public class TvStreamConfig implements android.os.Parcelable {
    method public int describeContents();
    method public int getGeneration();
    method public int getMaxHeight();
    method public int getMaxWidth();
    method public int getStreamId();
    method public int getType();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.media.tv.TvStreamConfig> CREATOR;
    field public static final int STREAM_TYPE_BUFFER_PRODUCER = 2; // 0x2
    field public static final int STREAM_TYPE_INDEPENDENT_VIDEO_SOURCE = 1; // 0x1
  }

  public static final class TvStreamConfig.Builder {
    ctor public TvStreamConfig.Builder();
    method public android.media.tv.TvStreamConfig build();
    method public android.media.tv.TvStreamConfig.Builder generation(int);
    method public android.media.tv.TvStreamConfig.Builder maxHeight(int);
    method public android.media.tv.TvStreamConfig.Builder maxWidth(int);
    method public android.media.tv.TvStreamConfig.Builder streamId(int);
    method public android.media.tv.TvStreamConfig.Builder type(int);
  }

  public class TvView extends android.view.ViewGroup {
    method public void requestUnblockContent(android.media.tv.TvContentRating);
    method public void sendAppPrivateCommand(String, android.os.Bundle);
    method public void setMain();
    method public void setZOrderMediaOverlay(boolean);
    method public void setZOrderOnTop(boolean);
    method public void tune(String, android.net.Uri, android.os.Bundle);
  }

  public abstract static class TvView.TvInputCallback {
    method public void onEvent(String, String, android.os.Bundle);
  }

}

package android.net {

  public class NetworkKey implements android.os.Parcelable {
    ctor public NetworkKey(android.net.WifiKey);
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.net.NetworkKey> CREATOR;
    field public static final int TYPE_WIFI = 1; // 0x1
    field public final int type;
    field public final android.net.WifiKey wifiKey;
  }

  public class NetworkScoreManager {
    method public boolean clearScores() throws java.lang.SecurityException;
    method public void disableScoring() throws java.lang.SecurityException;
    method public String getActiveScorerPackage();
    method public boolean setActiveScorer(String) throws java.lang.SecurityException;
    method public boolean updateScores(android.net.ScoredNetwork[]) throws java.lang.SecurityException;
    field public static final String ACTION_CHANGE_ACTIVE = "android.net.scoring.CHANGE_ACTIVE";
    field public static final String ACTION_CUSTOM_ENABLE = "android.net.scoring.CUSTOM_ENABLE";
    field public static final String ACTION_SCORER_CHANGED = "android.net.scoring.SCORER_CHANGED";
    field public static final String ACTION_SCORE_NETWORKS = "android.net.scoring.SCORE_NETWORKS";
    field public static final String EXTRA_NETWORKS_TO_SCORE = "networksToScore";
    field public static final String EXTRA_NEW_SCORER = "newScorer";
    field public static final String EXTRA_PACKAGE_NAME = "packageName";
  }

  public class RssiCurve implements android.os.Parcelable {
    ctor public RssiCurve(int, int, byte[]);
    ctor public RssiCurve(int, int, byte[], int);
    method public int describeContents();
    method public byte lookupScore(int);
    method public byte lookupScore(int, boolean);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.net.RssiCurve> CREATOR;
    field public final int activeNetworkRssiBoost;
    field public final int bucketWidth;
    field public final byte[] rssiBuckets;
    field public final int start;
  }

  public class ScoredNetwork implements android.os.Parcelable {
    ctor public ScoredNetwork(android.net.NetworkKey, android.net.RssiCurve);
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.net.ScoredNetwork> CREATOR;
    field public final android.net.NetworkKey networkKey;
    field public final android.net.RssiCurve rssiCurve;
  }

  public class TrafficStats {
    method public static void clearThreadStatsUid();
    method public static void setThreadStatsTagBackup();
    method public static void setThreadStatsUid(int);
  }

  public class VpnService extends android.app.Service {
    method public static void prepareAndAuthorize(android.content.Context);
  }

  public class WebAddress {
    ctor public WebAddress(String) throws android.net.ParseException;
  }

  public class WifiKey implements android.os.Parcelable {
    ctor public WifiKey(String, String);
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.net.WifiKey> CREATOR;
    field public final String bssid;
    field public final String ssid;
  }

}

package android.net.wifi {

  public class BatchedScanResult implements android.os.Parcelable {
    ctor public BatchedScanResult();
    ctor public BatchedScanResult(android.net.wifi.BatchedScanResult);
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public final java.util.List<android.net.wifi.ScanResult> scanResults;
    field public boolean truncated;
  }

  public class RttManager {
    method public android.net.wifi.RttManager.Capabilities getCapabilities();
    method public void startRanging(android.net.wifi.RttManager.RttParams[], android.net.wifi.RttManager.RttListener);
    method public void stopRanging(android.net.wifi.RttManager.RttListener);
    field public static final int BASE = 160256; // 0x27200
    field public static final int CMD_OP_ABORTED = 160260; // 0x27204
    field public static final int CMD_OP_FAILED = 160258; // 0x27202
    field public static final int CMD_OP_START_RANGING = 160256; // 0x27200
    field public static final int CMD_OP_STOP_RANGING = 160257; // 0x27201
    field public static final int CMD_OP_SUCCEEDED = 160259; // 0x27203
    field public static final String DESCRIPTION_KEY = "android.net.wifi.RttManager.Description";
    field public static final int REASON_INVALID_LISTENER = -3; // 0xfffffffd
    field public static final int REASON_INVALID_REQUEST = -4; // 0xfffffffc
    field public static final int REASON_NOT_AVAILABLE = -2; // 0xfffffffe
    field public static final int REASON_UNSPECIFIED = -1; // 0xffffffff
    field public static final int RTT_CHANNEL_WIDTH_10 = 6; // 0x6
    field public static final int RTT_CHANNEL_WIDTH_160 = 3; // 0x3
    field public static final int RTT_CHANNEL_WIDTH_20 = 0; // 0x0
    field public static final int RTT_CHANNEL_WIDTH_40 = 1; // 0x1
    field public static final int RTT_CHANNEL_WIDTH_5 = 5; // 0x5
    field public static final int RTT_CHANNEL_WIDTH_80 = 2; // 0x2
    field public static final int RTT_CHANNEL_WIDTH_80P80 = 4; // 0x4
    field public static final int RTT_CHANNEL_WIDTH_UNSPECIFIED = -1; // 0xffffffff
    field public static final int RTT_PEER_TYPE_AP = 1; // 0x1
    field public static final int RTT_PEER_TYPE_STA = 2; // 0x2
    field public static final int RTT_PEER_TYPE_UNSPECIFIED = 0; // 0x0
    field public static final int RTT_STATUS_ABORTED = 8; // 0x8
    field public static final int RTT_STATUS_FAILURE = 1; // 0x1
    field public static final int RTT_STATUS_FAIL_AP_ON_DIFF_CHANNEL = 6; // 0x6
    field public static final int RTT_STATUS_FAIL_NOT_SCHEDULED_YET = 4; // 0x4
    field public static final int RTT_STATUS_FAIL_NO_CAPABILITY = 7; // 0x7
    field public static final int RTT_STATUS_FAIL_NO_RSP = 2; // 0x2
    field public static final int RTT_STATUS_FAIL_REJECTED = 3; // 0x3
    field public static final int RTT_STATUS_FAIL_TM_TIMEOUT = 5; // 0x5
    field public static final int RTT_STATUS_SUCCESS = 0; // 0x0
    field public static final int RTT_TYPE_11_MC = 4; // 0x4
    field public static final int RTT_TYPE_11_V = 2; // 0x2
    field public static final int RTT_TYPE_ONE_SIDED = 1; // 0x1
    field public static final int RTT_TYPE_UNSPECIFIED = 0; // 0x0
  }

  public class RttManager.Capabilities {
    ctor public RttManager.Capabilities();
    field public int supportedPeerType;
    field public int supportedType;
  }

  public static class RttManager.ParcelableRttParams implements android.os.Parcelable {
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public android.net.wifi.RttManager.RttParams[] mParams;
  }

  public static class RttManager.ParcelableRttResults implements android.os.Parcelable {
    ctor public RttManager.ParcelableRttResults(android.net.wifi.RttManager.RttResult[]);
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public android.net.wifi.RttManager.RttResult[] mResults;
  }

  public static interface RttManager.RttListener {
    method public void onAborted();
    method public void onFailure(int, String);
    method public void onSuccess(android.net.wifi.RttManager.RttResult[]);
  }

  public static class RttManager.RttParams {
    ctor public RttManager.RttParams();
    field public String bssid;
    field public int channelWidth;
    field public int deviceType;
    field public int frequency;
    field public int num_retries;
    field public int num_samples;
    field public int requestType;
  }

  public static class RttManager.RttResult {
    ctor public RttManager.RttResult();
    field public String bssid;
    field public int distance_cm;
    field public int distance_sd_cm;
    field public int distance_spread_cm;
    field public int requestType;
    field public int rssi;
    field public int rssi_spread;
    field public long rtt_ns;
    field public long rtt_sd_ns;
    field public long rtt_spread_ns;
    field public int status;
    field public long ts;
    field public int tx_rate;
  }

  public class WifiConfiguration implements android.os.Parcelable {
    field public int creatorUid;
    field public int lastUpdateUid;
    field public int numAssociation;
    field public int numScorerOverride;
    field public int numScorerOverrideAndSwitchedNetwork;
  }

  public class WifiConnectionStatistics implements android.os.Parcelable {
    ctor public WifiConnectionStatistics();
    ctor public WifiConnectionStatistics(android.net.wifi.WifiConnectionStatistics);
    method public int describeContents();
    method public void incrementOrAddUntrusted(String, int, int);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.net.wifi.WifiConnectionStatistics> CREATOR;
    field public int num24GhzConnected;
    field public int num5GhzConnected;
    field public int numAutoJoinAttempt;
    field public int numAutoRoamAttempt;
    field public int numWifiManagerJoinAttempt;
    field public java.util.HashMap<java.lang.String,android.net.wifi.WifiNetworkConnectionStatistics> untrustedNetworkHistory;
  }

  public class WifiManager {
    method public java.util.List<android.net.wifi.BatchedScanResult> getBatchedScanResults();
    method public android.net.wifi.WifiConnectionStatistics getConnectionStatistics();
    method public java.util.List<android.net.wifi.WifiConfiguration> getPrivilegedConfiguredNetworks();
    method public boolean isBatchedScanSupported();
    method public boolean isDeviceToDeviceRttSupported();
    method public boolean isPortableHotspotSupported();
    method public boolean isWifiScannerSupported();
    method public boolean startLocationRestrictedScan(android.os.WorkSource);
    method public boolean startScan(android.os.WorkSource);
    field public static final int CHANGE_REASON_ADDED = 0; // 0x0
    field public static final int CHANGE_REASON_CONFIG_CHANGE = 2; // 0x2
    field public static final int CHANGE_REASON_REMOVED = 1; // 0x1
    field public static final String CONFIGURED_NETWORKS_CHANGED_ACTION = "android.net.wifi.CONFIGURED_NETWORKS_CHANGE";
    field public static final String EXTRA_CHANGE_REASON = "changeReason";
    field public static final String EXTRA_MULTIPLE_NETWORKS_CHANGED = "multipleChanges";
    field public static final String EXTRA_WIFI_CONFIGURATION = "wifiConfiguration";
  }

  public class WifiNetworkConnectionStatistics implements android.os.Parcelable {
    ctor public WifiNetworkConnectionStatistics(int, int);
    ctor public WifiNetworkConnectionStatistics();
    ctor public WifiNetworkConnectionStatistics(android.net.wifi.WifiNetworkConnectionStatistics);
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.net.wifi.WifiNetworkConnectionStatistics> CREATOR;
    field public int numConnection;
    field public int numUsage;
  }

  public class WifiScanner {
    method public void configureWifiChange(int, int, int, int, int, android.net.wifi.WifiScanner.BssidInfo[]);
    method public void configureWifiChange(android.net.wifi.WifiScanner.WifiChangeSettings);
    method public android.net.wifi.ScanResult[] getScanResults();
    method public void startBackgroundScan(android.net.wifi.WifiScanner.ScanSettings, android.net.wifi.WifiScanner.ScanListener);
    method public void startTrackingBssids(android.net.wifi.WifiScanner.BssidInfo[], int, android.net.wifi.WifiScanner.BssidListener);
    method public void startTrackingWifiChange(android.net.wifi.WifiScanner.WifiChangeListener);
    method public void stopBackgroundScan(android.net.wifi.WifiScanner.ScanListener);
    method public void stopTrackingBssids(android.net.wifi.WifiScanner.BssidListener);
    method public void stopTrackingWifiChange(android.net.wifi.WifiScanner.WifiChangeListener);
    field public static final int MAX_SCAN_PERIOD_MS = 1024000; // 0xfa000
    field public static final int MIN_SCAN_PERIOD_MS = 1000; // 0x3e8
    field public static final int REASON_INVALID_LISTENER = -2; // 0xfffffffe
    field public static final int REASON_INVALID_REQUEST = -3; // 0xfffffffd
    field public static final int REASON_NOT_AUTHORIZED = -4; // 0xfffffffc
    field public static final int REASON_SUCCEEDED = 0; // 0x0
    field public static final int REASON_UNSPECIFIED = -1; // 0xffffffff
    field public static final int REPORT_EVENT_AFTER_BUFFER_FULL = 0; // 0x0
    field public static final int REPORT_EVENT_AFTER_EACH_SCAN = 1; // 0x1
    field public static final int REPORT_EVENT_FULL_SCAN_RESULT = 2; // 0x2
    field public static final int WIFI_BAND_24_GHZ = 1; // 0x1
    field public static final int WIFI_BAND_5_GHZ = 2; // 0x2
    field public static final int WIFI_BAND_5_GHZ_DFS_ONLY = 4; // 0x4
    field public static final int WIFI_BAND_5_GHZ_WITH_DFS = 6; // 0x6
    field public static final int WIFI_BAND_BOTH = 3; // 0x3
    field public static final int WIFI_BAND_BOTH_WITH_DFS = 7; // 0x7
    field public static final int WIFI_BAND_UNSPECIFIED = 0; // 0x0
  }

  public static interface WifiScanner.ActionListener {
    method public void onFailure(int, String);
    method public void onSuccess();
  }

  public static class WifiScanner.BssidInfo {
    ctor public WifiScanner.BssidInfo();
    field public String bssid;
    field public int frequencyHint;
    field public int high;
    field public int low;
  }

  public static interface WifiScanner.BssidListener extends android.net.wifi.WifiScanner.ActionListener {
    method public void onFound(android.net.wifi.ScanResult[]);
  }

  public static class WifiScanner.ChannelSpec {
    ctor public WifiScanner.ChannelSpec(int);
    field public int frequency;
  }

  public static class WifiScanner.HotlistSettings implements android.os.Parcelable {
    ctor public WifiScanner.HotlistSettings();
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public int apLostThreshold;
    field public android.net.wifi.WifiScanner.BssidInfo[] bssidInfos;
  }

  public static interface WifiScanner.ScanListener extends android.net.wifi.WifiScanner.ActionListener {
    method public void onFullResult(android.net.wifi.ScanResult);
    method public void onPeriodChanged(int);
    method public void onResults(android.net.wifi.ScanResult[]);
  }

  public static class WifiScanner.ScanSettings implements android.os.Parcelable {
    ctor public WifiScanner.ScanSettings();
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public int band;
    field public android.net.wifi.WifiScanner.ChannelSpec[] channels;
    field public int numBssidsPerScan;
    field public int periodInMs;
    field public int reportEvents;
  }

  public static interface WifiScanner.WifiChangeListener extends android.net.wifi.WifiScanner.ActionListener {
    method public void onChanging(android.net.wifi.ScanResult[]);
    method public void onQuiescence(android.net.wifi.ScanResult[]);
  }

  public static class WifiScanner.WifiChangeSettings implements android.os.Parcelable {
    ctor public WifiScanner.WifiChangeSettings();
    method public int describeContents();
    method public void writeToParcel(android.os.Parcel, int);
    field public android.net.wifi.WifiScanner.BssidInfo[] bssidInfos;
    field public int lostApSampleSize;
    field public int minApsBreachingThreshold;
    field public int periodInMs;
    field public int rssiSampleSize;
    field public int unchangedSampleSize;
  }

}

package android.nfc {

  public final class NfcAdapter {
    method public boolean addNfcUnlockHandler(android.nfc.NfcAdapter.NfcUnlockHandler, String[]);
    method public boolean disable();
    method public boolean disable(boolean);
    method public boolean disableNdefPush();
    method public boolean enable();
    method public boolean enableNdefPush();
    method public boolean removeNfcUnlockHandler(android.nfc.NfcAdapter.NfcUnlockHandler);
    method public void setNdefPushMessage(android.nfc.NdefMessage, android.app.Activity, int);
    field public static final int FLAG_NDEF_PUSH_NO_CONFIRM = 1; // 0x1
  }

  public static interface NfcAdapter.NfcUnlockHandler {
    method public boolean onUnlockAttempted(android.nfc.Tag);
  }

}

package android.os {

  public final class PowerManager {
    method public void userActivity(long, int, int);
    field public static final int USER_ACTIVITY_EVENT_BUTTON = 1; // 0x1
    field public static final int USER_ACTIVITY_EVENT_OTHER = 0; // 0x0
    field public static final int USER_ACTIVITY_EVENT_TOUCH = 2; // 0x2
    field public static final int USER_ACTIVITY_FLAG_INDIRECT = 2; // 0x2
    field public static final int USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS = 1; // 0x1
  }

  public final class UserHandle implements android.os.Parcelable {
    method public int getIdentifier();
    method public boolean isOwner();
    method public static int myUserId();
  }

  public class UserManager {
    method public boolean isManagedProfile();
  }

}

package android.provider {

  public final class Settings {
    field public static final String ACTION_VOICE_CONTROL_AIRPLANE_MODE = "android.settings.VOICE_CONTROL_AIRPLANE_MODE";
    field public static final String EXTRA_AIRPLANE_MODE_ENABLED = "airplane_mode_enabled";
  }

}

package android.service.notification {

  public class Condition implements android.os.Parcelable {
    ctor public Condition(android.net.Uri, String, String, String, int, int, int);
    method public android.service.notification.Condition copy();
    method public int describeContents();
    method public static boolean isValidId(android.net.Uri, String);
    method public static android.net.Uri.Builder newId(android.content.Context);
    method public static String relevanceToString(int);
    method public static String stateToString(int);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.service.notification.Condition> CREATOR;
    field public static final int FLAG_RELEVANT_ALWAYS = 2; // 0x2
    field public static final int FLAG_RELEVANT_NOW = 1; // 0x1
    field public static final String SCHEME = "condition";
    field public static final int STATE_ERROR = 3; // 0x3
    field public static final int STATE_FALSE = 0; // 0x0
    field public static final int STATE_TRUE = 1; // 0x1
    field public static final int STATE_UNKNOWN = 2; // 0x2
    field public final int flags;
    field public final int icon;
    field public final android.net.Uri id;
    field public final String line1;
    field public final String line2;
    field public final int state;
    field public final String summary;
  }

  public abstract class ConditionProviderService extends android.app.Service {
    ctor public ConditionProviderService();
    method public final void notifyCondition(android.service.notification.Condition);
    method public final void notifyConditions(android.service.notification.Condition...);
    method public android.os.IBinder onBind(android.content.Intent);
    method public abstract void onConnected();
    method public abstract void onRequestConditions(int);
    method public abstract void onSubscribe(android.net.Uri);
    method public abstract void onUnsubscribe(android.net.Uri);
    field public static final String SERVICE_INTERFACE = "android.service.notification.ConditionProviderService";
  }

  public abstract class NotificationListenerService extends android.app.Service {
    method public android.service.notification.StatusBarNotification[] getActiveNotifications(int);
    method public android.service.notification.StatusBarNotification[] getActiveNotifications(String[], int);
    method public void registerAsSystemService(android.content.Context, android.content.ComponentName, int) throws android.os.RemoteException;
    method public final void setOnNotificationPostedTrim(int);
    method public void unregisterAsSystemService() throws android.os.RemoteException;
    field public static final int TRIM_FULL = 0; // 0x0
    field public static final int TRIM_LIGHT = 1; // 0x1
  }

}

package android.service.persistentdata {

  public interface IPersistentDataBlockService extends android.os.IInterface {
    method public int getDataBlockSize() throws android.os.RemoteException;
    method public long getMaximumDataBlockSize() throws android.os.RemoteException;
    method public boolean getOemUnlockEnabled() throws android.os.RemoteException;
    method public byte[] read() throws android.os.RemoteException;
    method public void setOemUnlockEnabled(boolean) throws android.os.RemoteException;
    method public void wipe() throws android.os.RemoteException;
    method public int write(byte[]) throws android.os.RemoteException;
  }

  public class PersistentDataBlockManager {
    ctor public PersistentDataBlockManager(android.service.persistentdata.IPersistentDataBlockService);
    method public int getDataBlockSize();
    method public long getMaximumDataBlockSize();
    method public boolean getOemUnlockEnabled();
    method public byte[] read();
    method public void setOemUnlockEnabled(boolean);
    method public void wipe();
    method public int write(byte[]);
  }

}

package android.service.trust {

  public class TrustAgentService extends android.app.Service {
    ctor public TrustAgentService();
    method public final void grantTrust(CharSequence, long, boolean);
    method public final android.os.IBinder onBind(android.content.Intent);
    method public boolean onConfigure(java.util.List<android.os.PersistableBundle>);
    method public void onDeviceLocked();
    method public void onDeviceUnlocked();
    method public void onTrustTimeout();
    method public void onUnlockAttempt(boolean);
    method public final void revokeTrust();
    method public final void setManagingTrust(boolean);
    field public static final String SERVICE_INTERFACE = "android.service.trust.TrustAgentService";
    field public static final String TRUST_AGENT_META_DATA = "android.service.trust.trustagent";
  }

}

package android.service.voice {

  public abstract class VoiceInteractionSession implements android.view.KeyEvent.Callback {
    method public android.view.LayoutInflater getLayoutInflater();
    method public android.app.Dialog getWindow();
    method public void hideWindow();
    method public void onBackPressed();
    method public void onComputeInsets(android.service.voice.VoiceInteractionSession.Insets);
    method public android.view.View onCreateContentView();
    method public void setTheme(int);
    method public void showWindow();
    method public void startVoiceActivity(android.content.Intent);
  }

  public static class VoiceInteractionSession.Caller {
  }

  public static final class VoiceInteractionSession.Insets {
    ctor public VoiceInteractionSession.Insets();
    field public static final int TOUCHABLE_INSETS_CONTENT = 1; // 0x1
    field public static final int TOUCHABLE_INSETS_FRAME = 0; // 0x0
    field public static final int TOUCHABLE_INSETS_REGION = 3; // 0x3
    field public final android.graphics.Rect contentInsets;
    field public int touchableInsets;
    field public final android.graphics.Region touchableRegion;
  }

  public static class VoiceInteractionSession.Request {
    method public void sendAbortVoiceResult(android.os.Bundle);
    method public void sendCancelResult();
    method public void sendCommandResult(boolean, android.os.Bundle);
    method public void sendCompleteVoiceResult(android.os.Bundle);
    method public void sendConfirmResult(boolean, android.os.Bundle);
  }

}

package android.telecom {

  public final class AudioState implements android.os.Parcelable {
    ctor public AudioState(boolean, int, int);
    ctor public AudioState(android.telecom.AudioState);
    method public int describeContents();
    method public int getRoute();
    method public int getSupportedRouteMask();
    method public boolean isMuted();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.telecom.AudioState> CREATOR;
    field public static final int ROUTE_BLUETOOTH = 2; // 0x2
    field public static final int ROUTE_EARPIECE = 1; // 0x1
    field public static final int ROUTE_SPEAKER = 8; // 0x8
    field public static final int ROUTE_WIRED_HEADSET = 4; // 0x4
    field public static final int ROUTE_WIRED_OR_EARPIECE = 5; // 0x5
    field public final boolean isMuted;
    field public final int route;
    field public final int supportedRouteMask;
  }

  public final class Call {
    method public void addListener(android.telecom.Call.Listener);
    method public void answer(int);
    method public void conference(android.telecom.Call);
    method public void disconnect();
    method public java.util.List<java.lang.String> getCannedTextResponses();
    method public java.util.List<android.telecom.Call> getChildren();
    method public java.util.List<android.telecom.Call> getConferenceableCalls();
    method public android.telecom.Call.Details getDetails();
    method public android.telecom.Call getParent();
    method public String getRemainingPostDialSequence();
    method public int getState();
    method public void hold();
    method public void mergeConference();
    method public void phoneAccountSelected(android.telecom.PhoneAccountHandle, boolean);
    method public void playDtmfTone(char);
    method public void postDialContinue(boolean);
    method public void reject(boolean, String);
    method public void removeListener(android.telecom.Call.Listener);
    method public void splitFromConference();
    method public void stopDtmfTone();
    method public void swapConference();
    method public void unhold();
    field public static final int STATE_ACTIVE = 4; // 0x4
    field public static final int STATE_CONNECTING = 9; // 0x9
    field public static final int STATE_DIALING = 1; // 0x1
    field public static final int STATE_DISCONNECTED = 7; // 0x7
    field public static final int STATE_DISCONNECTING = 10; // 0xa
    field public static final int STATE_HOLDING = 3; // 0x3
    field public static final int STATE_NEW = 0; // 0x0
    field public static final int STATE_PRE_DIAL_WAIT = 8; // 0x8
    field public static final int STATE_RINGING = 2; // 0x2
  }

  public static class Call.Details {
    method public static String capabilitiesToString(int);
    method public android.telecom.PhoneAccountHandle getAccountHandle();
    method public int getCallCapabilities();
    method public int getCallProperties();
    method public String getCallerDisplayName();
    method public int getCallerDisplayNamePresentation();
    method public long getConnectTimeMillis();
    method public android.telecom.DisconnectCause getDisconnectCause();
    method public android.os.Bundle getExtras();
    method public android.telecom.GatewayInfo getGatewayInfo();
    method public android.net.Uri getHandle();
    method public int getHandlePresentation();
    method public android.telecom.StatusHints getStatusHints();
    method public int getVideoState();
    field public static final int CAPABILITY_DISCONNECT_FROM_CONFERENCE = 8192; // 0x2000
    field public static final int CAPABILITY_HOLD = 1; // 0x1
    field public static final int CAPABILITY_MANAGE_CONFERENCE = 128; // 0x80
    field public static final int CAPABILITY_MERGE_CONFERENCE = 4; // 0x4
    field public static final int CAPABILITY_MUTE = 64; // 0x40
    field public static final int CAPABILITY_RESPOND_VIA_TEXT = 32; // 0x20
    field public static final int CAPABILITY_SEPARATE_FROM_CONFERENCE = 4096; // 0x1000
    field public static final int CAPABILITY_SUPPORT_HOLD = 2; // 0x2
    field public static final int CAPABILITY_SWAP_CONFERENCE = 8; // 0x8
  }

  public abstract static class Call.Listener {
    ctor public Call.Listener();
    method public void onCallDestroyed(android.telecom.Call);
    method public void onCannedTextResponsesLoaded(android.telecom.Call, java.util.List<java.lang.String>);
    method public void onChildrenChanged(android.telecom.Call, java.util.List<android.telecom.Call>);
    method public void onConferenceableCallsChanged(android.telecom.Call, java.util.List<android.telecom.Call>);
    method public void onDetailsChanged(android.telecom.Call, android.telecom.Call.Details);
    method public void onParentChanged(android.telecom.Call, android.telecom.Call);
    method public void onPostDialWait(android.telecom.Call, String);
    method public void onStateChanged(android.telecom.Call, int);
  }

  public final class CallState {
    method public static String toString(int);
    field public static final int ABORTED = 8; // 0x8
    field public static final int ACTIVE = 5; // 0x5
    field public static final int CONNECTING = 1; // 0x1
    field public static final int DIALING = 3; // 0x3
    field public static final int DISCONNECTED = 7; // 0x7
    field public static final int DISCONNECTING = 9; // 0x9
    field public static final int NEW = 0; // 0x0
    field public static final int ON_HOLD = 6; // 0x6
    field public static final int PRE_DIAL_WAIT = 2; // 0x2
    field public static final int RINGING = 4; // 0x4
  }

  public abstract class Conference implements android.telecom.IConferenceable {
    ctor public Conference(android.telecom.PhoneAccountHandle);
    method public final boolean addConnection(android.telecom.Connection);
    method public final void destroy();
    method public final android.telecom.AudioState getAudioState();
    method public final java.util.List<android.telecom.Connection> getConferenceableConnections();
    method public long getConnectTimeMillis();
    method public final int getConnectionCapabilities();
    method public final java.util.List<android.telecom.Connection> getConnections();
    method public final android.telecom.DisconnectCause getDisconnectCause();
    method public final android.telecom.PhoneAccountHandle getPhoneAccountHandle();
    method public android.telecom.Connection getPrimaryConnection();
    method public final int getState();
    method public void onAudioStateChanged(android.telecom.AudioState);
    method public void onConnectionAdded(android.telecom.Connection);
    method public void onDisconnect();
    method public void onHold();
    method public void onMerge(android.telecom.Connection);
    method public void onMerge();
    method public void onPlayDtmfTone(char);
    method public void onSeparate(android.telecom.Connection);
    method public void onStopDtmfTone();
    method public void onSwap();
    method public void onUnhold();
    method public final void removeConnection(android.telecom.Connection);
    method public final void setActive();
    method public final void setConferenceableConnections(java.util.List<android.telecom.Connection>);
    method public void setConnectTimeMillis(long);
    method public final void setConnectionCapabilities(int);
    method public final void setDisconnected(android.telecom.DisconnectCause);
    method public final void setOnHold();
    field public static long CONNECT_TIME_NOT_SPECIFIED;
    field protected android.telecom.PhoneAccountHandle mPhoneAccount;
  }

  public abstract class Connection implements android.telecom.IConferenceable {
    ctor public Connection();
    method public static String capabilitiesToString(int);
    method public static android.telecom.Connection createCanceledConnection();
    method public static android.telecom.Connection createFailedConnection(android.telecom.DisconnectCause);
    method public final void destroy();
    method public final android.net.Uri getAddress();
    method public final int getAddressPresentation();
    method public final boolean getAudioModeIsVoip();
    method public final android.telecom.AudioState getAudioState();
    method @Deprecated public final int getCallCapabilities();
    method public final String getCallerDisplayName();
    method public final int getCallerDisplayNamePresentation();
    method public final android.telecom.Conference getConference();
    method public final java.util.List<android.telecom.IConferenceable> getConferenceables();
    method public final int getConnectionCapabilities();
    method public final android.telecom.DisconnectCause getDisconnectCause();
    method public final int getState();
    method public final android.telecom.StatusHints getStatusHints();
    method public final boolean isRingbackRequested();
    method protected void notifyConferenceStarted();
    method public void onAbort();
    method public void onAnswer();
    method public void onAudioStateChanged(android.telecom.AudioState);
    method public void onDisconnect();
    method public void onHold();
    method public void onPlayDtmfTone(char);
    method public void onPostDialContinue(boolean);
    method public void onReject();
    method public void onSeparate();
    method public void onStateChanged(int);
    method public void onStopDtmfTone();
    method public void onUnhold();
    method public final void setActive();
    method public final void setAddress(android.net.Uri, int);
    method public final void setAudioModeIsVoip(boolean);
    method @Deprecated public final void setCallCapabilities(int);
    method public final void setCallerDisplayName(String, int);
    method public final void setConferenceableConnections(java.util.List<android.telecom.Connection>);
    method public final void setConferenceables(java.util.List<android.telecom.IConferenceable>);
    method public final void setConnectionCapabilities(int);
    method public final void setConnectionService(android.telecom.ConnectionService);
    method public final void setDialing();
    method public final void setDisconnected(android.telecom.DisconnectCause);
    method public final void setInitialized();
    method public final void setInitializing();
    method public final void setOnHold();
    method public final void setPostDialWait(String);
    method public final void setRingbackRequested(boolean);
    method public final void setRinging();
    method public final void setStatusHints(android.telecom.StatusHints);
    method public static String stateToString(int);
    field public static final int CAPABILITY_DISCONNECT_FROM_CONFERENCE = 8192; // 0x2000
    field public static final int CAPABILITY_HOLD = 1; // 0x1
    field public static final int CAPABILITY_MANAGE_CONFERENCE = 128; // 0x80
    field public static final int CAPABILITY_MERGE_CONFERENCE = 4; // 0x4
    field public static final int CAPABILITY_MUTE = 64; // 0x40
    field public static final int CAPABILITY_RESPOND_VIA_TEXT = 32; // 0x20
    field public static final int CAPABILITY_SEPARATE_FROM_CONFERENCE = 4096; // 0x1000
    field public static final int CAPABILITY_SUPPORT_HOLD = 2; // 0x2
    field public static final int CAPABILITY_SWAP_CONFERENCE = 8; // 0x8
    field public static final int STATE_ACTIVE = 4; // 0x4
    field public static final int STATE_DIALING = 3; // 0x3
    field public static final int STATE_DISCONNECTED = 6; // 0x6
    field public static final int STATE_HOLDING = 5; // 0x5
    field public static final int STATE_INITIALIZING = 0; // 0x0
    field public static final int STATE_NEW = 1; // 0x1
    field public static final int STATE_RINGING = 2; // 0x2
  }

  public final class ConnectionRequest implements android.os.Parcelable {
    ctor public ConnectionRequest(android.telecom.PhoneAccountHandle, android.net.Uri, android.os.Bundle);
    method public int describeContents();
    method public android.telecom.PhoneAccountHandle getAccountHandle();
    method public android.net.Uri getAddress();
    method public android.os.Bundle getExtras();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.telecom.ConnectionRequest> CREATOR;
  }

  public abstract class ConnectionService extends android.app.Service {
    ctor public ConnectionService();
    method public final void addConference(android.telecom.Conference);
    method public final void addExistingConnection(android.telecom.PhoneAccountHandle, android.telecom.Connection);
    method public final void conferenceRemoteConnections(android.telecom.RemoteConnection, android.telecom.RemoteConnection);
    method public final android.telecom.RemoteConnection createRemoteIncomingConnection(android.telecom.PhoneAccountHandle, android.telecom.ConnectionRequest);
    method public final android.telecom.RemoteConnection createRemoteOutgoingConnection(android.telecom.PhoneAccountHandle, android.telecom.ConnectionRequest);
    method public final java.util.Collection<android.telecom.Connection> getAllConnections();
    method public final android.os.IBinder onBind(android.content.Intent);
    method public void onConference(android.telecom.Connection, android.telecom.Connection);
    method public android.telecom.Connection onCreateIncomingConnection(android.telecom.PhoneAccountHandle, android.telecom.ConnectionRequest);
    method public android.telecom.Connection onCreateOutgoingConnection(android.telecom.PhoneAccountHandle, android.telecom.ConnectionRequest);
    method public void onRemoteConferenceAdded(android.telecom.RemoteConference);
    method public void onRemoteExistingConnectionAdded(android.telecom.RemoteConnection);
    field public static final String SERVICE_INTERFACE = "android.telecom.ConnectionService";
  }

  public final class DisconnectCause implements android.os.Parcelable {
    ctor public DisconnectCause(int);
    ctor public DisconnectCause(int, String);
    ctor public DisconnectCause(int, CharSequence, CharSequence, String);
    ctor public DisconnectCause(int, CharSequence, CharSequence, String, int);
    method public int describeContents();
    method public int getCode();
    method public CharSequence getDescription();
    method public CharSequence getLabel();
    method public String getReason();
    method public int getTone();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final int BUSY = 7; // 0x7
    field public static final int CANCELED = 4; // 0x4
    field public static final int CONNECTION_MANAGER_NOT_SUPPORTED = 10; // 0xa
    field public static final android.os.Parcelable.Creator<android.telecom.DisconnectCause> CREATOR;
    field public static final int ERROR = 1; // 0x1
    field public static final int LOCAL = 2; // 0x2
    field public static final int MISSED = 5; // 0x5
    field public static final int OTHER = 9; // 0x9
    field public static final int REJECTED = 6; // 0x6
    field public static final int REMOTE = 3; // 0x3
    field public static final int RESTRICTED = 8; // 0x8
    field public static final int UNKNOWN = 0; // 0x0
  }

  public class GatewayInfo implements android.os.Parcelable {
    ctor public GatewayInfo(String, android.net.Uri, android.net.Uri);
    method public int describeContents();
    method public android.net.Uri getGatewayAddress();
    method public String getGatewayProviderPackageName();
    method public android.net.Uri getOriginalAddress();
    method public boolean isEmpty();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.telecom.GatewayInfo> CREATOR;
  }

  public interface IConferenceable {
  }

  public abstract class InCallService extends android.app.Service {
    ctor public InCallService();
    method public android.telecom.Phone getPhone();
    method public android.os.IBinder onBind(android.content.Intent);
    method public void onPhoneCreated(android.telecom.Phone);
    method public void onPhoneDestroyed(android.telecom.Phone);
    field public static final String SERVICE_INTERFACE = "android.telecom.InCallService";
  }

  public final class Phone {
    method public void addListener(android.telecom.Phone.Listener);
    method public boolean canAddCall();
    method public android.telecom.AudioState getAudioState();
    method public java.util.List<android.telecom.Call> getCalls();
    method public void removeListener(android.telecom.Phone.Listener);
    method public void setAudioRoute(int);
    method public void setMuted(boolean);
    method public void setProximitySensorOff(boolean);
    method public void setProximitySensorOn();
  }

  public abstract static class Phone.Listener {
    ctor public Phone.Listener();
    method public void onAudioStateChanged(android.telecom.Phone, android.telecom.AudioState);
    method public void onBringToForeground(android.telecom.Phone, boolean);
    method public void onCallAdded(android.telecom.Phone, android.telecom.Call);
    method public void onCallRemoved(android.telecom.Phone, android.telecom.Call);
    method public void onCanAddCallChanged(android.telecom.Phone, boolean);
  }

  public class PhoneAccount implements android.os.Parcelable {
    method public static android.telecom.PhoneAccount.Builder builder(android.telecom.PhoneAccountHandle, CharSequence);
    method public android.graphics.drawable.Drawable createIconDrawable(android.content.Context);
    method public int describeContents();
    method public android.telecom.PhoneAccountHandle getAccountHandle();
    method public android.net.Uri getAddress();
    method public int getCapabilities();
    method public int getHighlightColor();
    method public android.graphics.Bitmap getIconBitmap();
    method public String getIconPackageName();
    method public int getIconResId();
    method public int getIconTint();
    method public CharSequence getLabel();
    method public CharSequence getShortDescription();
    method public android.net.Uri getSubscriptionAddress();
    method public java.util.List<java.lang.String> getSupportedUriSchemes();
    method public boolean hasCapabilities(int);
    method public boolean supportsUriScheme(String);
    method public void writeToParcel(android.os.Parcel, int);
    field public static final int CAPABILITY_CONNECTION_MANAGER = 1; // 0x1
    field public static final int CAPABILITY_PLACE_EMERGENCY_CALLS = 16; // 0x10
    field public static final int CAPABILITY_SIM_SUBSCRIPTION = 4; // 0x4
    field public static final android.os.Parcelable.Creator<android.telecom.PhoneAccount> CREATOR;
    field public static final int NO_HIGHLIGHT_COLOR = 0; // 0x0
    field public static final int NO_ICON_TINT = 0; // 0x0
    field public static final int NO_RESOURCE_ID = -1; // 0xffffffff
    field public static final String SCHEME_SIP = "sip";
    field public static final String SCHEME_TEL = "tel";
    field public static final String SCHEME_VOICEMAIL = "voicemail";
  }

  public static class PhoneAccount.Builder {
    ctor public PhoneAccount.Builder(android.telecom.PhoneAccountHandle, CharSequence);
    ctor public PhoneAccount.Builder(android.telecom.PhoneAccount);
    method public android.telecom.PhoneAccount build();
    method public android.telecom.PhoneAccount.Builder setAddress(android.net.Uri);
    method public android.telecom.PhoneAccount.Builder setCapabilities(int);
    method public android.telecom.PhoneAccount.Builder setHighlightColor(int);
    method public android.telecom.PhoneAccount.Builder setIcon(android.content.Context, int);
    method public android.telecom.PhoneAccount.Builder setIcon(String, int);
    method public android.telecom.PhoneAccount.Builder setIcon(android.content.Context, int, int);
    method public android.telecom.PhoneAccount.Builder setIcon(String, int, int);
    method public android.telecom.PhoneAccount.Builder setIcon(android.graphics.Bitmap);
    method public android.telecom.PhoneAccount.Builder setShortDescription(CharSequence);
    method public android.telecom.PhoneAccount.Builder setSubscriptionAddress(android.net.Uri);
    method public android.telecom.PhoneAccount.Builder setSupportedUriSchemes(java.util.List<java.lang.String>);
  }

  public class PhoneAccountHandle implements android.os.Parcelable {
    ctor public PhoneAccountHandle(android.content.ComponentName, String);
    method public int describeContents();
    method public android.content.ComponentName getComponentName();
    method public String getId();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.telecom.PhoneAccountHandle> CREATOR;
  }

  public final class RemoteConference {
    method public void disconnect();
    method public java.util.List<android.telecom.RemoteConnection> getConferenceableConnections();
    method public int getConnectionCapabilities();
    method public java.util.List<android.telecom.RemoteConnection> getConnections();
    method public android.telecom.DisconnectCause getDisconnectCause();
    method public int getState();
    method public void hold();
    method public void merge();
    method public void playDtmfTone(char);
    method public void registerCallback(android.telecom.RemoteConference.Callback);
    method public void separate(android.telecom.RemoteConnection);
    method public void setAudioState(android.telecom.AudioState);
    method public void stopDtmfTone();
    method public void swap();
    method public void unhold();
    method public void unregisterCallback(android.telecom.RemoteConference.Callback);
  }

  public abstract static class RemoteConference.Callback {
    ctor public RemoteConference.Callback();
    method public void onConferenceableConnectionsChanged(android.telecom.RemoteConference, java.util.List<android.telecom.RemoteConnection>);
    method public void onConnectionAdded(android.telecom.RemoteConference, android.telecom.RemoteConnection);
    method public void onConnectionCapabilitiesChanged(android.telecom.RemoteConference, int);
    method public void onConnectionRemoved(android.telecom.RemoteConference, android.telecom.RemoteConnection);
    method public void onDestroyed(android.telecom.RemoteConference);
    method public void onDisconnected(android.telecom.RemoteConference, android.telecom.DisconnectCause);
    method public void onStateChanged(android.telecom.RemoteConference, int, int);
  }

  public final class RemoteConnection {
    method public void abort();
    method public void answer();
    method public void disconnect();
    method public android.net.Uri getAddress();
    method public int getAddressPresentation();
    method public CharSequence getCallerDisplayName();
    method public int getCallerDisplayNamePresentation();
    method public android.telecom.RemoteConference getConference();
    method public java.util.List<android.telecom.RemoteConnection> getConferenceableConnections();
    method public int getConnectionCapabilities();
    method public android.telecom.DisconnectCause getDisconnectCause();
    method public int getState();
    method public android.telecom.StatusHints getStatusHints();
    method public void hold();
    method public boolean isRingbackRequested();
    method public boolean isVoipAudioMode();
    method public void playDtmfTone(char);
    method public void postDialContinue(boolean);
    method public void registerCallback(android.telecom.RemoteConnection.Callback);
    method public void reject();
    method public void setAudioState(android.telecom.AudioState);
    method public void stopDtmfTone();
    method public void unhold();
    method public void unregisterCallback(android.telecom.RemoteConnection.Callback);
  }

  public abstract static class RemoteConnection.Callback {
    ctor public RemoteConnection.Callback();
    method public void onAddressChanged(android.telecom.RemoteConnection, android.net.Uri, int);
    method public void onCallerDisplayNameChanged(android.telecom.RemoteConnection, String, int);
    method public void onConferenceChanged(android.telecom.RemoteConnection, android.telecom.RemoteConference);
    method public void onConferenceableConnectionsChanged(android.telecom.RemoteConnection, java.util.List<android.telecom.RemoteConnection>);
    method public void onConnectionCapabilitiesChanged(android.telecom.RemoteConnection, int);
    method public void onDestroyed(android.telecom.RemoteConnection);
    method public void onDisconnected(android.telecom.RemoteConnection, android.telecom.DisconnectCause);
    method public void onPostDialChar(android.telecom.RemoteConnection, char);
    method public void onPostDialWait(android.telecom.RemoteConnection, String);
    method public void onRingbackRequested(android.telecom.RemoteConnection, boolean);
    method public void onStateChanged(android.telecom.RemoteConnection, int);
    method public void onStatusHintsChanged(android.telecom.RemoteConnection, android.telecom.StatusHints);
    method public void onVoipAudioChanged(android.telecom.RemoteConnection, boolean);
  }

  public final class StatusHints implements android.os.Parcelable {
    ctor public StatusHints(android.content.ComponentName, CharSequence, int, android.os.Bundle);
    method public int describeContents();
    method public android.os.Bundle getExtras();
    method public android.graphics.drawable.Drawable getIcon(android.content.Context);
    method public int getIconResId();
    method public CharSequence getLabel();
    method public android.content.ComponentName getPackageName();
    method public void writeToParcel(android.os.Parcel, int);
    field public static final android.os.Parcelable.Creator<android.telecom.StatusHints> CREATOR;
  }

  public class TelecomManager {
    method public void acceptRingingCall();
    method public void addNewIncomingCall(android.telecom.PhoneAccountHandle, android.os.Bundle);
    method public void addNewUnknownCall(android.telecom.PhoneAccountHandle, android.os.Bundle);
    method public void clearAccounts();
    method public boolean endCall();
    method public android.net.Uri getAdnUriForPhoneAccount(android.telecom.PhoneAccountHandle);
    method public java.util.List<android.telecom.PhoneAccountHandle> getAllPhoneAccountHandles();
    method public java.util.List<android.telecom.PhoneAccount> getAllPhoneAccounts();
    method public int getAllPhoneAccountsCount();
    method public int getCallState();
    method public android.telecom.PhoneAccountHandle getConnectionManager();
    method public android.telecom.PhoneAccountHandle getDefaultOutgoingPhoneAccount(String);
    method public android.content.ComponentName getDefaultPhoneApp();
    method public String getLine1Number(android.telecom.PhoneAccountHandle);
    method public android.telecom.PhoneAccount getPhoneAccount(android.telecom.PhoneAccountHandle);
    method public java.util.List<android.telecom.PhoneAccountHandle> getPhoneAccountsForPackage();
    method public java.util.List<android.telecom.PhoneAccountHandle> getPhoneAccountsSupportingScheme(String);
    method public java.util.List<android.telecom.PhoneAccountHandle> getRegisteredConnectionManagers();
    method public boolean handleMmi(android.telecom.PhoneAccountHandle, String);
    method public boolean hasMultipleCallCapableAccounts();
    method public boolean hasVoiceMailNumber(android.telecom.PhoneAccountHandle);
    method public boolean isRinging();
    method public boolean isTtySupported();
    method public boolean isVoiceMailNumber(android.telecom.PhoneAccountHandle, String);
    method public void registerPhoneAccount(android.telecom.PhoneAccount);
    method public void silenceRinger();
    method public void unregisterPhoneAccount(android.telecom.PhoneAccountHandle);
    field public static final String ACTION_CHANGE_PHONE_ACCOUNTS = "android.telecom.action.CHANGE_PHONE_ACCOUNTS";
    field public static final String ACTION_CONNECTION_SERVICE_CONFIGURE = "android.telecom.action.CONNECTION_SERVICE_CONFIGURE";
    field public static final String EXTRA_CALL_BACK_NUMBER = "android.telecom.extra.CALL_BACK_NUMBER";
    field public static final String EXTRA_CONNECTION_SERVICE = "android.telecom.extra.CONNECTION_SERVICE";
    field public static final String EXTRA_INCOMING_CALL_EXTRAS = "android.telecom.extra.INCOMING_CALL_EXTRAS";
    field public static final String EXTRA_OUTGOING_CALL_EXTRAS = "android.telecom.extra.OUTGOING_CALL_EXTRAS";
    field public static final String EXTRA_PHONE_ACCOUNT_HANDLE = "android.telecom.extra.PHONE_ACCOUNT_HANDLE";
  }

}

package android.telephony {

  public class TelephonyManager {
    method public void answerRingingCall();
    method public void call(String, String);
    method public int checkCarrierPrivilegesForPackage(String);
    method public void dial(String);
    method public boolean disableDataConnectivity();
    method public boolean enableDataConnectivity();
    method public void enableVideoCalling(boolean);
    method public boolean endCall();
    method public java.util.List<java.lang.String> getCarrierPackageNamesForIntent(android.content.Intent);
    method public String getCdmaMdn();
    method public String getCdmaMdn(int);
    method public String getCdmaMin();
    method public String getCdmaMin(int);
    method public int getCurrentPhoneType();
    method public int getCurrentPhoneType(int);
    method public boolean getDataEnabled();
    method public boolean getDataEnabled(int);
    method public boolean handlePinMmi(String);
    method public boolean handlePinMmiForSubscriber(int, String);
    method public boolean isDataConnectivityPossible();
    method public boolean isIdle();
    method public boolean isOffhook();
    method public boolean isRadioOn();
    method public boolean isRinging();
    method public boolean isSimPinEnabled();
    method public boolean isVideoCallingEnabled();
    method public boolean needsOtaServiceProvisioning();
    method public void setDataEnabled(boolean);
    method public void setDataEnabled(int, boolean);
    method public boolean setRadio(boolean);
    method public boolean setRadioPower(boolean);
    method public void silenceRinger();
    method public boolean supplyPin(String);
    method public int[] supplyPinReportResult(String);
    method public boolean supplyPuk(String, String);
    method public int[] supplyPukReportResult(String, String);
    method public void toggleRadioOnOff();
    method public void updateServiceLocation();
  }

}

package android.view {

  public abstract class Window {
    method public void setDisableWallpaperTouchEvents(boolean);
  }

}

package android.webkit {

  public abstract class CookieManager {
    method protected abstract boolean allowFileSchemeCookiesImpl();
    method public abstract String getCookie(String, boolean);
    method public String getCookie(android.net.WebAddress);
    method public abstract boolean hasCookies(boolean);
    method protected abstract void setAcceptFileSchemeCookiesImpl(boolean);
  }

  public class FindActionModeCallback implements android.view.ActionMode.Callback android.text.TextWatcher android.view.View.OnClickListener android.webkit.WebView.FindListener {
    ctor public FindActionModeCallback(android.content.Context);
    method public void afterTextChanged(android.text.Editable);
    method public void beforeTextChanged(CharSequence, int, int, int);
    method public void findAll();
    method public void finish();
    method public int getActionModeGlobalBottom();
    method public boolean onActionItemClicked(android.view.ActionMode, android.view.MenuItem);
    method public void onClick(android.view.View);
    method public boolean onCreateActionMode(android.view.ActionMode, android.view.Menu);
    method public void onDestroyActionMode(android.view.ActionMode);
    method public void onFindResultReceived(int, int, boolean);
    method public boolean onPrepareActionMode(android.view.ActionMode, android.view.Menu);
    method public void onTextChanged(CharSequence, int, int, int);
    method public void setText(String);
    method public void setWebView(android.webkit.WebView);
    method public void showSoftInput();
    method public void updateMatchCount(int, int, boolean);
  }

  public static class FindActionModeCallback.NoAction implements android.view.ActionMode.Callback {
    ctor public FindActionModeCallback.NoAction();
    method public boolean onActionItemClicked(android.view.ActionMode, android.view.MenuItem);
    method public boolean onCreateActionMode(android.view.ActionMode, android.view.Menu);
    method public void onDestroyActionMode(android.view.ActionMode);
    method public boolean onPrepareActionMode(android.view.ActionMode, android.view.Menu);
  }

  public class GeolocationPermissions {
    ctor public GeolocationPermissions();
  }

  public class HttpAuthHandler extends android.os.Handler {
    ctor public HttpAuthHandler();
  }

  public class JsDialogHelper {
    ctor public JsDialogHelper(android.webkit.JsPromptResult, int, String, String, String);
    ctor public JsDialogHelper(android.webkit.JsPromptResult, android.os.Message);
    method public boolean invokeCallback(android.webkit.WebChromeClient, android.webkit.WebView);
    method public void showDialog(android.content.Context);
    field public static final int ALERT = 1; // 0x1
    field public static final int CONFIRM = 2; // 0x2
    field public static final int PROMPT = 3; // 0x3
    field public static final int UNLOAD = 4; // 0x4
  }

  public class JsPromptResult extends android.webkit.JsResult {
    ctor public JsPromptResult(android.webkit.JsResult.ResultReceiver);
    method public String getStringResult();
  }

  public class JsResult {
    ctor public JsResult(android.webkit.JsResult.ResultReceiver);
    method public final boolean getResult();
  }

  public static interface JsResult.ResultReceiver {
    method public void onJsResultComplete(android.webkit.JsResult);
  }

  public class SslErrorHandler extends android.os.Handler {
    ctor public SslErrorHandler();
  }

  public class WebChromeClient {
    method @Deprecated public void openFileChooser(android.webkit.ValueCallback<android.net.Uri>, String, String);
  }

  public abstract class WebHistoryItem implements java.lang.Cloneable {
    method @Deprecated public abstract int getId();
  }

  @Deprecated public abstract class WebIconDatabase {
    method @Deprecated public abstract void bulkRequestIconForPageUrl(android.content.ContentResolver, String, android.webkit.WebIconDatabase.IconListener);
  }

  public abstract class WebSettings {
    method public abstract boolean getAcceptThirdPartyCookies();
    method @Deprecated public abstract boolean getNavDump();
    method @Deprecated public abstract boolean getPluginsEnabled();
    method @Deprecated public abstract boolean getUseWebViewBackgroundForOverscrollBackground();
    method @Deprecated public abstract int getUserAgent();
    method public abstract boolean getVideoOverlayForEmbeddedEncryptedVideoEnabled();
    method public abstract void setAcceptThirdPartyCookies(boolean);
    method @Deprecated public abstract void setNavDump(boolean);
    method @Deprecated public abstract void setPluginsEnabled(boolean);
    method @Deprecated public abstract void setUseWebViewBackgroundForOverscrollBackground(boolean);
    method @Deprecated public abstract void setUserAgent(int);
    method public abstract void setVideoOverlayForEmbeddedEncryptedVideoEnabled(boolean);
  }

  public class WebStorage {
    ctor public WebStorage();
  }

  public static class WebStorage.Origin {
    ctor protected WebStorage.Origin(String, long, long);
  }

  public class WebView extends android.widget.AbsoluteLayout implements android.view.ViewGroup.OnHierarchyChangeListener android.view.ViewTreeObserver.OnGlobalFocusChangeListener {
    method public android.webkit.WebViewProvider getWebViewProvider();
    field public static final String DATA_REDUCTION_PROXY_SETTING_CHANGED = "android.webkit.DATA_REDUCTION_PROXY_SETTING_CHANGED";
  }

  public static class WebView.HitTestResult {
    ctor public WebView.HitTestResult();
    method public void setExtra(String);
    method public void setType(int);
  }

  public class WebView.PrivateAccess {
    ctor public WebView.PrivateAccess();
    method public void awakenScrollBars(int);
    method public void awakenScrollBars(int, boolean);
    method public float getHorizontalScrollFactor();
    method public int getHorizontalScrollbarHeight();
    method public float getVerticalScrollFactor();
    method public void onScrollChanged(int, int, int, int);
    method public void overScrollBy(int, int, int, int, int, int, int, int, boolean);
    method public void setMeasuredDimension(int, int);
    method public void setScrollXRaw(int);
    method public void setScrollYRaw(int);
    method public void super_computeScroll();
    method public boolean super_dispatchKeyEvent(android.view.KeyEvent);
    method public int super_getScrollBarStyle();
    method public void super_onDrawVerticalScrollBar(android.graphics.Canvas, android.graphics.drawable.Drawable, int, int, int, int);
    method public boolean super_onGenericMotionEvent(android.view.MotionEvent);
    method public boolean super_onHoverEvent(android.view.MotionEvent);
    method public boolean super_performAccessibilityAction(int, android.os.Bundle);
    method public boolean super_performLongClick();
    method public boolean super_requestFocus(int, android.graphics.Rect);
    method public void super_scrollTo(int, int);
    method public boolean super_setFrame(int, int, int, int);
    method public void super_setLayoutParams(android.view.ViewGroup.LayoutParams);
  }

  public final class WebViewDelegate {
    method public void addWebViewAssetPath(android.content.Context);
    method public void callDrawGlFunction(android.graphics.Canvas, long);
    method public boolean canInvokeDrawGlFunctor(android.view.View);
    method public void detachDrawGlFunctor(android.view.View, long);
    method public android.app.Application getApplication();
    method public String getErrorString(android.content.Context, int);
    method public int getPackageId(android.content.res.Resources, String);
    method public void invokeDrawGlFunctor(android.view.View, long, boolean);
    method public boolean isTraceTagEnabled();
    method public void setOnTraceEnabledChangeListener(android.webkit.WebViewDelegate.OnTraceEnabledChangeListener);
  }

  public static interface WebViewDelegate.OnTraceEnabledChangeListener {
    method public void onTraceEnabledChange(boolean);
  }

  public final class WebViewFactory {
    ctor public WebViewFactory();
    method public static android.content.pm.PackageInfo getLoadedPackageInfo();
    method public static String getWebViewPackageName();
    method public static void onWebViewUpdateInstalled();
    method public static void prepareWebViewInSystemServer();
    method public static void prepareWebViewInZygote();
    field public static final String CHROMIUM_WEBVIEW_VMSIZE_SIZE_PROPERTY = "persist.sys.webview.vmsize";
  }

  public interface WebViewFactoryProvider {
    method public android.webkit.WebViewProvider createWebView(android.webkit.WebView, android.webkit.WebView.PrivateAccess);
    method public android.webkit.CookieManager getCookieManager();
    method public android.webkit.GeolocationPermissions getGeolocationPermissions();
    method public android.webkit.WebViewFactoryProvider.Statics getStatics();
    method public android.webkit.WebIconDatabase getWebIconDatabase();
    method public android.webkit.WebStorage getWebStorage();
    method public android.webkit.WebViewDatabase getWebViewDatabase(android.content.Context);
  }

  public static interface WebViewFactoryProvider.Statics {
    method public void clearClientCertPreferences(Runnable);
    method public void enableSlowWholeDocumentDraw();
    method public String findAddress(String);
    method public void freeMemoryForTests();
    method public String getDefaultUserAgent(android.content.Context);
    method public android.net.Uri[] parseFileChooserResult(int, android.content.Intent);
    method public void setWebContentsDebuggingEnabled(boolean);
  }

  public interface WebViewProvider {
    method public void addJavascriptInterface(Object, String);
    method public boolean canGoBack();
    method public boolean canGoBackOrForward(int);
    method public boolean canGoForward();
    method public boolean canZoomIn();
    method public boolean canZoomOut();
    method public android.graphics.Picture capturePicture();
    method public void clearCache(boolean);
    method public void clearFormData();
    method public void clearHistory();
    method public void clearMatches();
    method public void clearSslPreferences();
    method public void clearView();
    method public android.webkit.WebBackForwardList copyBackForwardList();
    method public android.print.PrintDocumentAdapter createPrintDocumentAdapter(String);
    method public void destroy();
    method public void documentHasImages(android.os.Message);
    method public void dumpViewHierarchyWithProperties(java.io.BufferedWriter, int);
    method public void evaluateJavaScript(String, android.webkit.ValueCallback<java.lang.String>);
    method public int findAll(String);
    method public void findAllAsync(String);
    method public android.view.View findHierarchyView(String, int);
    method public void findNext(boolean);
    method public void flingScroll(int, int);
    method public void freeMemory();
    method public android.net.http.SslCertificate getCertificate();
    method public int getContentHeight();
    method public int getContentWidth();
    method public android.graphics.Bitmap getFavicon();
    method public android.webkit.WebView.HitTestResult getHitTestResult();
    method public String[] getHttpAuthUsernamePassword(String, String);
    method public String getOriginalUrl();
    method public int getProgress();
    method public float getScale();
    method public android.webkit.WebViewProvider.ScrollDelegate getScrollDelegate();
    method public android.webkit.WebSettings getSettings();
    method public String getTitle();
    method public String getTouchIconUrl();
    method public String getUrl();
    method public android.webkit.WebViewProvider.ViewDelegate getViewDelegate();
    method public int getVisibleTitleHeight();
    method public android.view.View getZoomControls();
    method public void goBack();
    method public void goBackOrForward(int);
    method public void goForward();
    method public void init(java.util.Map<java.lang.String,java.lang.Object>, boolean);
    method public void invokeZoomPicker();
    method public boolean isPaused();
    method public boolean isPrivateBrowsingEnabled();
    method public void loadData(String, String, String);
    method public void loadDataWithBaseURL(String, String, String, String, String);
    method public void loadUrl(String, java.util.Map<java.lang.String,java.lang.String>);
    method public void loadUrl(String);
    method public void notifyFindDialogDismissed();
    method public void onPause();
    method public void onResume();
    method public boolean overlayHorizontalScrollbar();
    method public boolean overlayVerticalScrollbar();
    method public boolean pageDown(boolean);
    method public boolean pageUp(boolean);
    method public void pauseTimers();
    method public void postUrl(String, byte[]);
    method public void reload();
    method public void removeJavascriptInterface(String);
    method public void requestFocusNodeHref(android.os.Message);
    method public void requestImageRef(android.os.Message);
    method public boolean restorePicture(android.os.Bundle, java.io.File);
    method public android.webkit.WebBackForwardList restoreState(android.os.Bundle);
    method public void resumeTimers();
    method public void savePassword(String, String, String);
    method public boolean savePicture(android.os.Bundle, java.io.File);
    method public android.webkit.WebBackForwardList saveState(android.os.Bundle);
    method public void saveWebArchive(String);
    method public void saveWebArchive(String, boolean, android.webkit.ValueCallback<java.lang.String>);
    method public void setCertificate(android.net.http.SslCertificate);
    method public void setDownloadListener(android.webkit.DownloadListener);
    method public void setFindListener(android.webkit.WebView.FindListener);
    method public void setHorizontalScrollbarOverlay(boolean);
    method public void setHttpAuthUsernamePassword(String, String, String, String);
    method public void setInitialScale(int);
    method public void setMapTrackballToArrowKeys(boolean);
    method public void setNetworkAvailable(boolean);
    method public void setPictureListener(android.webkit.WebView.PictureListener);
    method public void setVerticalScrollbarOverlay(boolean);
    method public void setWebChromeClient(android.webkit.WebChromeClient);
    method public void setWebViewClient(android.webkit.WebViewClient);
    method public boolean showFindDialog(String, boolean);
    method public void stopLoading();
    method public boolean zoomBy(float);
    method public boolean zoomIn();
    method public boolean zoomOut();
  }

  public static interface WebViewProvider.ScrollDelegate {
    method public int computeHorizontalScrollOffset();
    method public int computeHorizontalScrollRange();
    method public void computeScroll();
    method public int computeVerticalScrollExtent();
    method public int computeVerticalScrollOffset();
    method public int computeVerticalScrollRange();
  }

  public static interface WebViewProvider.ViewDelegate {
    method public boolean dispatchKeyEvent(android.view.KeyEvent);
    method public android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider();
    method public void onAttachedToWindow();
    method public void onConfigurationChanged(android.content.res.Configuration);
    method public android.view.inputmethod.InputConnection onCreateInputConnection(android.view.inputmethod.EditorInfo);
    method public void onDetachedFromWindow();
    method public void onDraw(android.graphics.Canvas);
    method public void onDrawVerticalScrollBar(android.graphics.Canvas, android.graphics.drawable.Drawable, int, int, int, int);
    method public void onFinishTemporaryDetach();
    method public void onFocusChanged(boolean, int, android.graphics.Rect);
    method public boolean onGenericMotionEvent(android.view.MotionEvent);
    method public boolean onHoverEvent(android.view.MotionEvent);
    method public void onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent);
    method public void onInitializeAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo);
    method public boolean onKeyDown(int, android.view.KeyEvent);
    method public boolean onKeyMultiple(int, int, android.view.KeyEvent);
    method public boolean onKeyUp(int, android.view.KeyEvent);
    method public void onMeasure(int, int);
    method public void onOverScrolled(int, int, boolean, boolean);
    method public void onScrollChanged(int, int, int, int);
    method public void onSizeChanged(int, int, int, int);
    method public void onStartTemporaryDetach();
    method public boolean onTouchEvent(android.view.MotionEvent);
    method public boolean onTrackballEvent(android.view.MotionEvent);
    method public void onVisibilityChanged(android.view.View, int);
    method public void onWindowFocusChanged(boolean);
    method public void onWindowVisibilityChanged(int);
    method public boolean performAccessibilityAction(int, android.os.Bundle);
    method public boolean performLongClick();
    method public void preDispatchDraw(android.graphics.Canvas);
    method public boolean requestChildRectangleOnScreen(android.view.View, android.graphics.Rect, boolean);
    method public boolean requestFocus(int, android.graphics.Rect);
    method public void setBackgroundColor(int);
    method public boolean setFrame(int, int, int, int);
    method public void setLayerType(int, android.graphics.Paint);
    method public void setLayoutParams(android.view.ViewGroup.LayoutParams);
    method public void setOverScrollMode(int);
    method public void setScrollBarStyle(int);
    method public boolean shouldDelayChildPressedState();
  }

}

